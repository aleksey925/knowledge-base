Теория баз данных 
=================

# Оглавление
1. <h3>[Общее](#Общее)</h3>
    - [Нормализация баз данных. Нормальные формы](#Нормализация-баз-данных-Нормальные-формы)
    - [Уровни изоляции транзакций](#Уровни-изоляции-транзакций)
    
2. <h3>[Индексы](#Индексы)</h3>
    - [Использование b-tree в базах данных](#Использование-b-tree-в-базах-данных)


<a name='Общее'></a>
## Общее

<a name='Нормализация-баз-данных-Нормальные-формы'></a>
### Нормализация баз данных. Нормальные формы

**Первая нормальная форма**

Отношение находится в 1НФ, если все поля (атрибуты) таблицы
хранят простые (атамарные) значения, то есть в одной ячейке не может 
перечисляться несколько значений.

*Неправильно*

Фирма   |   Модели 
--------|-------------
BMW     | M5, X5M, M1
Nissan  | GT-R


*Правильно*

Фирма   |   Модели 
--------|-----------
BMW     | M5
BMW     | X5M
BMW     | M1
Nissan  | GT-R


**Вторая нормальная форма**

Отношение находится во 2НФ, если оно находится в 1НФ и в таблице нет 
столбцов, которые не связаны логически с первичным ключом таблицы.

>Под первичным ключом понимают поле или набор полей, однозначно (уникально) 
>идентифицирующих запись.

Например, дана таблица:

Модель | Фирма | Цена    | Скидка
-------|-------|---------|--------
M5     | BMW   | 5500000 | 5%
X5M    | BMW   | 6000000 | 5%
M1     | BMW   | 2500000 | 5%
GT-R   | Nissan| 5000000 | 10%

Таблица находится в первой нормальной форме, но не во второй. Цены машин 
зависят от модели и фирмы, а скидки зависят только от фирмы, то есть 
зависимость от первичного ключа неполная. Исправляется это путем разбиения 
на две таблицы.

Модель | Фирма | Цена    
-------|-------|---------
M5     | BMW   | 5500000 
X5M    | BMW   | 6000000 
M1     | BMW   | 2500000 
GT-R   | Nissan| 5000000


Фирма  | Скидка    
-------|--------
BMW    | 5% 
Nissan | 10%
 
 
**Третья нормальная форма** 

Отношение находится в 3НФ, если оно находится во 2НФ и все не ключевые столбцы,
значения которых могут относиться к нескольким записям таблицы должны быть
вынесены в отдельные таблицы.

Рассмотрим таблицу:

Модель | Магазин    | Телефон
-------|------------|---------
BMW    | Риал-авто  | 87-33-98
Audi   | Риал-авто  | 87-33-98
Nissan | Некст-Авто | 94-54-12

Таблица находится во 2НФ, но не в 3НФ.
В отношении столбец «Модель» является первичным ключом. Личных телефонов у 
автомобилей нет, и телефон зависит исключительно от магазина. По этому 
отношение Магазин -> Телефон необходимо вынести в отдельную таблицу.

Модель | Магазин    
-------|------------
BMW    | Риал-авто  
Audi   | Риал-авто  
Nissan | Некст-Авто 


Магазин    | Телефон
-----------|---------
Риал-авто  | 87-33-98
Риал-авто  | 87-33-98
Некст-Авто | 94-54-12


Прочитать все тоже самое, но написаннное научным языком 
можно [тут](https://habr.com/post/254773/).


<a name='Уровни-изоляции-транзакций'></a>
### Уровни изоляции транзакций

**Истоки проблемы**

Напомним, что транзакцией называется упорядоченное множество действий, которые выполняются или все вместе или не 
выполняются вовсе. В применении к SQL транзакция включает в себя один и более операторов языка. Уровни изоляций 
транзакций с разной степенью обеспечивают целостность данных при их одновременной обработке множеством процессов 
(пользователей). Наиболее простой вариант: один пользователь записывает информацию на уровне записи таблицы, другой 
пытается ее прочитать. При отсутствии изоляции второй пользователь может прочитать данные незавершенной транзакции. 
Ситуация усложняется, если изменениям (модификации, вставке, удалению) подвержена не одна запись, а несколько, возможно
даже в разных таблицах.

**Незавершенное (черновое) чтение (read uncommitted)**

Минимальный уровень изоляции, гарантирует только физическую целостность при записи данных. Процессы-читатели могут 
считывать данные незавершенной транзакции процесса-писателя.

**Подтвержденное чтение (read committed)**

Процессы-читатели не могут считывать данные незавершенной транзакции, но процессы-писатели
могут изменять уже прочитанные читателем данные.

**Повторяемое чтение (repeatable read)**

Повторное чтение данных вернет те же значения, что и в начале транзакции. При этом процессы-писатели могут вставлять 
новые записи, имеющие статус "фантома" при незавершенной транзакции.

**Версионный срез (snapshot)**

Процессы-читатели не ждут завершения транзакций писателей, а считывают данные, точнее их версию, по состоянию на момент 
начала своей транзакции.

**Сериализуемость (serializable)**

Максимальный уровень изоляции, гарантирует неизменяемость данных другими процессами до завершения транзакции.

Ссылки:

- [первоисточник](https://arbinada.com/en/node/619)



<a name='Индексы'></a>
## Индексы

<a name='Использование-b-tree-в-базах-данных'></a>
### Использование b-tree в базах данных

[Локальная копия доклада](https://cloud.mail.ru/public/531a/2ZfQBdbiL), [Владимир Кузнецов - Базы данных B-tree](https://www.youtube.com/watch?v=TdtulzNC9iE)

Видео содержит: описание способа хранения данных на основе страничной модели. 
Исторические предпосылки. Устройство B-tree индексов. Особенности реализации, 
сильные и слабые стороны этого подхода.
