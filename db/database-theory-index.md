Теория баз данных 
=================

# Оглавление
1. <h3>[Общее](#Общее)</h3>
    - [Нормализация баз данных. Нормальные формы](#Нормализация-баз-данных-Нормальные-формы)
    
2. <h3>[Индексы](#Индексы)</h3>
    - [Использование b-tree в базах данных](#Использование-b-tree-в-базах-данных)
    - [Общая информация по индексам в PostgreSQL](#Общая-информация-по-индексам-в-PostgreSQL)


<a name='Общее'></a>
## Общее

<a name='Нормализация-баз-данных-Нормальные-формы'></a>
### Нормализация баз данных. Нормальные формы

**Первая нормальная форма**

Отношение находится в 1НФ, если все поля (атрибуты) таблицы
хранят простые (атамарные) значения, то есть в одной ячейке не может 
перечисляться несколько значений.

*Неправильно*

Фирма   |   Модели 
--------|-------------
BMW     | M5, X5M, M1
Nissan  | GT-R


*Правильно*

Фирма   |   Модели 
--------|-----------
BMW     | M5
BMW     | X5M
BMW     | M1
Nissan  | GT-R


**Вторая нормальная форма**

Отношение находится во 2НФ, если оно находится в 1НФ и в таблице нет 
столбцов, которые не связаны логически с первичным ключом таблицы.

>Под первичным ключом понимают поле или набор полей, однозначно (уникально) 
>идентифицирующих запись.

Например, дана таблица:

Модель | Фирма | Цена    | Скидка
-------|-------|---------|--------
M5     | BMW   | 5500000 | 5%
X5M    | BMW   | 6000000 | 5%
M1     | BMW   | 2500000 | 5%
GT-R   | Nissan| 5000000 | 10%

Таблица находится в первой нормальной форме, но не во второй. Цены машин 
зависят от модели и фирмы, а скидки зависят только от фирмы, то есть 
зависимость от первичного ключа неполная. Исправляется это путем разбиения 
на две таблицы.

Модель | Фирма | Цена    
-------|-------|---------
M5     | BMW   | 5500000 
X5M    | BMW   | 6000000 
M1     | BMW   | 2500000 
GT-R   | Nissan| 5000000


Фирма  | Скидка    
-------|--------
BMW    | 5% 
Nissan | 10%
 
 
**Третья нормальная форма** 

Отношение находится в 3НФ, если оно находится во 2НФ и все не ключевые столбцы,
значения которых могут относиться к нескольким записям таблицы должны быть
вынесены в отдельные таблицы.

Рассмотрим таблицу:

Модель | Магазин    | Телефон
-------|------------|---------
BMW    | Риал-авто  | 87-33-98
Audi   | Риал-авто  | 87-33-98
Nissan | Некст-Авто | 94-54-12

Таблица находится во 2НФ, но не в 3НФ.
В отношении столбец «Модель» является первичным ключом. Личных телефонов у 
автомобилей нет, и телефон зависит исключительно от магазина. По этому 
отношение Магазин -> Телефон необходимо вынести в отдельную таблицу.

Модель | Магазин    
-------|------------
BMW    | Риал-авто  
Audi   | Риал-авто  
Nissan | Некст-Авто 


Магазин    | Телефон
-----------|---------
Риал-авто  | 87-33-98
Риал-авто  | 87-33-98
Некст-Авто | 94-54-12


Прочитать все тоже самое, но написаннное научным языком 
можно [тут](https://habr.com/post/254773/).


<a name='Индексы'></a>
## Индексы

<a name='Использование-b-tree-в-базах-данных'></a>
### Использование b-tree в базах данных

[Локальная копия доклада](https://cloud.mail.ru/public/531a/2ZfQBdbiL), [Владимир Кузнецов - Базы данных B-tree](https://www.youtube.com/watch?v=TdtulzNC9iE)

Видео содержит: описание способа хранения данных на основе страничной модели. 
Исторические предпосылки. Устройство B-tree индексов. Особенности реализации, 
сильные и слабые стороны этого подхода.


<a name='Общая-информация-по-индексам-в-PostgreSQL'></a>
### Общая информация по индексам в PostgreSQL

Индексы помогают ускорить операций, требующие выборки ограниченных данных. Это:

- операции `select`, `update` и `delete`, в которых присутствует условие `where`;

- операция `join` и подобные ей (если индекс создан для полей, по которым происходит объединение);

- некоторые случаи, где присутствует `ORDER BY`.


#### Создание и удаление индексов

В самом базовом случае команда создания индекса выглядит следующим образом:

```sql
CREATE INDEX index_name ON table_name (column_name);
```

Чтобы создать уникальный индекс, который не позволяет создавать несколько записей с одинаковым значением в поле, 
нужно добавить модификатор UNIQUE. Уникальность поддерживают только B-tree индексы.

```sql
CREATE UNIQUE INDEX index_name ON table_name (column_name);
```

На время создания индекса таблица остается доступной для чтения, но блокируется для изменений. В виду того, что 
создание индекса для больших таблиц может быть не быстрым, это не всегда допустимо. PostgreSQL позволяет создавать 
индексы без блокировки изменений таблицы. Для этого надо воспользоваться конкурентным созданием, добавив модификатор 
CONCURRENTLY. Естественно в этом случае создание индекса займет больше времени, плюс просядет производительность.

```sql
CREATE CONCURRENTLY INDEX index_name ON table_name (column_name);
```

Есть пара моментов, о которых стоит помнить:

- нельзя конкурентно создавать несколько индексов для одной таблицы одновременно;

- в отличие от обычного создания, конкурентное не может быть обернуто в транзакцию.


Для удаления индекса необходимо воспользоваться запросом вида:

```sql
DROP INDEX name;
```

**Пересоздание индексов (реиндекс)**

Иногда индекс может выйти из строя и для нормальной работы его необходимо пересоздать. Это может понадобиться в случае 
программного или аппаратного сбоя, раздутия индекса, смены настроек СУБД или падения во время конкурентного создания 
индекса. Для этого служит один из следующих запросов.

```
REINDEX INDEX index_name; /* Пересоздаст индекс index_name */
REINDEX TABLE table_name; /* Пересоздаст все индексы в таблице table_name */
REINDEX DATABASE database_name; /* Пересоздаст все индексы в базе database_name */
```


#### Типы индексов

PostgreSQL позволяет создавать индексы нескольких типов: B-tree, GIN, GiST, BRIN и HASH. Каждый из них использует свой 
алгоритм работы и подходит для определенных запросов. По умолчанию создаются индексы типа B-tree, как поддерживающий 
наиболее часто используемые операции. Чтобы создать индекс другого типа надо указать его явно, добавив модификатор 
USING type.

```sql
CREATE INDEX index_name ON table_name USING type (column_name);
```

Рассмотрим подробнее каждый тип.

**B-tree**

B-tree строит индексы используя [одноименную реализацию](https://ru.wikipedia.org/wiki/B-дерево) сбалансированного 
дерева. Может использоваться в случаях, если к индексированному полю применяются:

- операторы сравнения >, <, =, >=, <=, BETWEEN и IN;

- условия пустоты IS NULL и IS NOT NULL;
- операторы поиска подстроки LIKE и ~, если искомая строка закреплена в начале шаблона (например str_1 LIKE 'search%');
- регистронезависимые операторы поиска подстроки ILIKE и ~*. Но только в том случае, если искомая строка начинается с 
  символа, который одинаков и в верхнем и в нижнем регистре (например числа)`.

**GiST**

GiST для построения индексов использует один из нескольких алгоритмов, наиболее подходящих под тип индексируемого поля. 
Поэтому набор операторов при работе с которыми может быть задействован этот индекс зависит от типа поля. По умолчанию 
PostgreSQL предоставляет индексы для некоторых типов данных, таких как 
[геометрические типы](https://www.postgresql.org/docs/9.5/datatype-geometric.html), 
[сетевые адреса](https://www.postgresql.org/docs/9.1/static/datatype-net-types.html), 
[диапазоны](https://www.postgresql.org/docs/9.2/static/rangetypes.html) и т.д. Так же этот список можно расширить, 
установив соответствующие модули.

Вот список типов полей и индексируемых операторов для них. Значение операторов для каждого конкретного типа можно найти 
в официальной документации.

- типы box, circle и polygon - операторы &&, &>, &<, &<|, >>, <<, <<|, <@, @>, @, |&>, |>>, ~, ~=;
- типы inet и cidr - операторы &&, >>, >>=, >, >=, <>, <<, <<=, <, <=, =;
- тип point - операторы >>, >^, <<, <@, <@, <@, <^, ~=;
- тип tsquery - операторы <@, @>;
- тип tsvector - оператор @@;
- все типы range - операторы &&, &>, &<, >>, <<, <@, -|-, =, @>, @>.

**GIN**

GIN индексы применимы к составным типам, работа с которыми осуществляется с помощью ключей. Это массивы, jsonb и 
tsvector. Как и GiST индексы, они могут реализовать один из нескольких алгоритмов. И стандартный набор можно так же 
расширить, установив модули.

Ниже приведен список типов полей и индексируемых операторов для них. Значение операторов для каждого конкретного типа 
можно найти в официальной документации.

- массивы - операторы &&, <@, =, @>;
- тип jsonb - операторы ?, ?&, ?|, @>;
- тип tsvector - операторы @@ и @@@.

Так же GIN индекс может быть создан только для определенных полей jsonb.

**BRIN**

BRIN индекс отчается от остальных, его идея не в том, чтобы быстро найти нужные строки, а в том, чтобы избежать 
просмотра заведомо ненужных, то есть **ускорить последовательное сканирование** таблицы. Это всегда неточный индекс: он 
вообще не содержит TID-ов табличных строк (ссылок на конкретные строки).

Упрощенно говоря, BRIN хорошо работает для тех столбцов, значения в которых коррелируют с их физическим расположением в 
таблице. Иными словами, если запрос без предложения ORDER BY выдает значения столбца практически в порядке возрастания 
или убывания (и при этом по столбцу нет индексов).

Работает это следующим образом. Таблица разбивается на зоны (range) размером в несколько страниц (или блоков, что то же 
самое) — отсюда и название: Block Range Index, BRIN. Для каждой зоны в индексе сохраняется сводная информация о данных 
в этой зоне. Как правило, это минимальное и максимальное значения, но бывает и иначе. Если при выполнении запроса, 
содержащего условие на столбец, искомые значения не попадают в диапазон, то всю зону можно смело пропускать; если же 
попадают — все строки во всех блоках зоны придется просмотреть и выбрать среди них подходящие.

BRIN можно применять к большому количеству типов данных, вот некоторые из них: числа, строки, дата/время, диопазоны и 
т.д. Список поддерживаемых операторов зависит от типа столбца, для большинства типов поддерживаются операторы 
`<`, `<=`, `=`, `>=`, `>`. Полный список поддерживаемых типов и операторов можно посмотреть в 
[официальной документации](https://postgrespro.ru/docs/postgresql/13/brin-builtin-opclasses#brin-builtin-opclasses-table).

Один из примеров, когда уместно использовать данный индекс это логи или истории заказов магазина, которые пишутся 
последовательно, а потому некоторые колонки (дата, время, номер) частично упорядочены уже на физическом уровне.

Отличительные особенности:

- небольшой размер;
- минимальные накладные расходы на поддержание (разрабатывался для таблиц размеров в несколько терабайтов или даже 
  десятков терабайт).

Детали реализации можно посмотреть [здесь](https://habr.com/ru/company/postgrespro/blog/346460/) и 
[здесь](https://ru.wikipedia.org/wiki/BRIN).

**HASH**

Hash индексы могут использоваться, только если проиндексированное поле участвует в сравнении (только оператор =). Этот 
индекс так же не используется в условиях IS NULL и IS NOT NULL. 

В старых версиях postgres (например 9.5) этот тип индекса не рекомендуется использовать.

> Операции с хеш-индексами в настоящее время не проходят через WAL, так что после аварийной остановки базы данных может 
> потребоваться перестроить хеш-индексы командой REINDEX. Кроме того, изменения в хеш-индексах после начальной копии не
> переносятся при потоковой или файловой репликации, так что в последующих запросах они будут давать неправильные 
> ответы. По этим причинам настоятельно рекомендуется не использовать их.

В новых версиях эти проблемы исправили.

#### Составные индексы

Индекс можно построить больше чем по одному полю. Для построения индекса по нескольких полям - составного индекса, 
надо просто перечислить входящие в него поля через запятую.

```sql
CREATE INDEX index_name ON table_name (column_name_1, compumn_name_2);
```

Максимальное количество полей в индексе - 32. Это значение может быть изменено, если вы самостоятельно компилируете 
PostgreSQL из исходников. Но на практике индексы, состоящие больше чем из трех полей, практически не применяются.

Составными могут быть индексы только B-tree, GiST и GIN типов. Составные индексы могут использоваться, когда в условии 
участвуют все поля, входящие в индекс. Так же составной индекс может быть использован, если условие касается только 
одного или нескольких проиндексированных полей. Для каждого типа есть свои особенности.

**B-tree**

B-tree индекс может быть использован, когда условие включает в себя любые входящие в него поля. Но наиболее полезен он 
в том случае, если в условии задействовано ведущее (первое в списке) поле.

**GiST**

GiST индекс может использоваться в тех же условиях, что и B-tree. Помимо этого эффективность индекса сильно снижается, 
если условие по ведущему полю отсекает мало значений. Нужно стараться так составлять индекс, чтобы наиболее строгое 
ограничение применялось к ведущему полю.

**GIN**

Составной GIN индекс одинаково эффективен при использовании любого входящего в него поля не зависимо от его 
расположения. Это отличает его от B-tree и GiST индексов, где условие по ведущему полю сильно желательно.

**Частичные индексы**

Иногда может возникать ситуация, что индекс требуются не для всех записей в таблице. Например, у нас есть таблица users, 
у которой есть поле is_active типа boolean. Записей со значением поля true намного меньше, чем с false. Но логично, 
что основная часть запросов идет к активным пользователям. В этом случае будет разумно построить индекс только для них. 
PostgreSQL предоставляет такую возможность.

Для создания частичного индекса надо добавить модификатор WHERE в запрос на создание.

```sql
CREATE INDEX index_name ON table_name (column_name) WHERE condition;
```

Вот запрос на создание частичного индекса для поля `users.rating` с условием `is_active = true`:

```sql
CREATE INDEX active_users ON users (rating) WHERE is_active = true;
```

Составные и уникальные индексы тоже могут быть частичными.

#### Функциональные индексы

Порой возникает необходимость создания индекса не для конкретного поля/полей, а для результата выражения. Например, 
если мы часто ищем записи в таблице `users` по имени и фамилии одной строкой. Пример такого запроса:

```sql
SELECT * FROM users where (name || ' ' || surname) = 'Haru Atari';
```

Здесь может сильно помочь функциональный индекс. Для его создания используется обычный запрос, но вместо полей, надо 
указать выражение. Запрос на создание индекса для нашего случая будет выглядеть так:

```sql
CREATE INDEX active_users ON users ((name || ' ' || surname));
```

Важно понимать, что функциональные индексы хранят результат выражения и вычисляют его при вставке или обновлении записи.
Из-за этого сильно возрастает скорость чтения т.к. теперь нет необходимости высчитывать значения выражения для каждой 
записи, а достаточно произвести простое сравнение. Но при этом сильно просаживается скорость при создании и 
редактировании записей т.к. при этом еще и рассчитывается новое значение для индекса.


> Данная заметка скопирована с [сайта](https://web.archive.org/web/20190116120501/https://haru-atari.com/ru/blog/6/indexes-in-postgresql-full-manual),  
> после того как владелец удалил свой блог.
 

Полезные ссылки:
   
   - [Индексы - Postgres документация](https://postgrespro.ru/docs/postgresql/13/indexes-types)
   - [Индексы в PostgreSQL — 9 - habr (описание работы brin индексов)](https://habr.com/ru/company/postgrespro/blog/346460/)
   - [BRIN - wikipedia](https://ru.wikipedia.org/wiki/BRIN)
