PostgreSQL
==========

# Оглавление

- [Установка/настройка](#Установка-настройка)
    - [Установка на MacOS](#Установка-на-MacOS)
    - [Установка утилит](#Установка-утилит)
    - [Конфигурирование](#Конфигурирование)
    - [Импортирование дампа БД](#Импортирование-дампа-БД)

- [Туториалы](#Туториалы)

- [Теория](#Теория)
    - [Общая информация по индексам](#Общая-информация-по-индексам)
    - [Оптимизация запросов](#Оптимизация-запросов)

- [Примеры решения задач](#Примеры-решения-задач)
    - [Запрет на созадние записей пересекающихся по времени](#Запрет-на-созадние-записей-пересекающихся-по-времени)


<a name='Установка-настройка'></a>
## Установка/настройка


<a name='Установка-на-MacOS'></a>
### Установка на MacOS

Установить postgres на macos можно при помощи [PostgresApp](https://postgresapp.com). 

Данное приложение предоставляет простой и удобный GUI, который позволяет устанавливать и управлять postgres.


<a name='Установка-утилит'></a>
### Установка утилит

При установке дистрибутива postgres устанавливается не только сама СУБД, но 
еще и разные вспомогательные утилиты. Иногда бывает так, что сама СУБД, не 
нужна, а нужны только утилиты для работы с ней. В этом случае можно 
воспользоваться специальными пакетами, которые установят только утилиты.

**MacOS**

В MacOS установить утилиты для работы с postgres можно при помощи brew

```bash
brew install libpq
```

После установки пакета найти установленные утилиты можно в 
`/usr/local/Cellar/libpq/<версия-пакета>/bin/`.


<a name='Конфигурирование'></a>
### Конфигурирование

http://pgconfigurator.cybertec.at/ - онлайн конфигуратор postgres


<a name='Импортирование-дампа-БД'></a>
### Импортирование дампа БД

Данная инструкция проверялась и обкатывалась под ubuntu, будет она работать на других платформах или нет, не известно.

Для импортирования дампа БД, необходимо:

1. Подключиться к СУБД через оболочку

    ```bash
    sudo -u postgres psql
    ``` 

2. Создать базу данных, пользователя и дать новому пользователю права на 
   созданную БД

    ```sql
    CREATE DATABASE <db_name>;
    CREATE USER <user_name> WITH password '<you_password>';
    GRANT ALL ON DATABASE <db_name> TO <user_name>;
    ```  

3. Теперь можно выйти из оболочки, для этого введите команду `\q`. Оказавшись 
   в терминале необходимо выполнить команду:

    ```bash
    psql -h localhost -d <db_name> -U <user_name> -W -f </path/to/db_dump.sql>
    ```
    
    db_name и user_name это значения введенные Вами на предыдущем этапе.



<a name='Туториалы'></a>
## Туториалы

- https://metanit.com/sql/postgresql/1.1.php - простой и хорошо 
структуризированный манул для начинающих. Есть описание установки сервера,
примеры различных запросов и т д



<a name='Теория'></a>
## Теория


<a name='Общая-информация-по-индексам'></a>
### Общая информация по индексам

Индексы помогают ускорить операций, требующие выборки ограниченных данных. Это:

- операции `select`, `update` и `delete`, в которых присутствует условие `where`;

- операция `join` и подобные ей (если индекс создан для полей, по которым происходит объединение);

- некоторые случаи, где присутствует `ORDER BY`.


#### Создание и удаление индексов

В самом базовом случае команда создания индекса выглядит следующим образом:

```sql
CREATE INDEX index_name ON table_name (column_name);
```

Чтобы создать уникальный индекс, который не позволяет создавать несколько записей с одинаковым значением в поле, 
нужно добавить модификатор UNIQUE. Уникальность поддерживают только B-tree индексы.

```sql
CREATE UNIQUE INDEX index_name ON table_name (column_name);
```

На время создания индекса таблица остается доступной для чтения, но блокируется для изменений. В виду того, что 
создание индекса для больших таблиц может быть не быстрым, это не всегда допустимо. PostgreSQL позволяет создавать 
индексы без блокировки изменений таблицы. Для этого надо воспользоваться конкурентным созданием, добавив модификатор 
CONCURRENTLY. Естественно в этом случае создание индекса займет больше времени, плюс просядет производительность.

```sql
CREATE INDEX CONCURRENTLY index_name ON table_name (column_name);
```

Есть пара моментов, о которых стоит помнить:

- нельзя конкурентно создавать несколько индексов для одной таблицы одновременно;

- в отличие от обычного создания, конкурентное не может быть обернуто в транзакцию.


Для удаления индекса необходимо воспользоваться запросом вида:

```sql
DROP INDEX name;
```

**Пересоздание индексов (реиндекс)**

Иногда индекс может выйти из строя и для нормальной работы его необходимо пересоздать. Это может понадобиться в случае 
программного или аппаратного сбоя, раздутия индекса, смены настроек СУБД или падения во время конкурентного создания 
индекса. Для этого служит один из следующих запросов.

```sql
REINDEX INDEX index_name; /* Пересоздаст индекс index_name */
REINDEX TABLE table_name; /* Пересоздаст все индексы в таблице table_name */
REINDEX DATABASE database_name; /* Пересоздаст все индексы в базе database_name */
```

#### Типы индексов

PostgreSQL позволяет создавать индексы нескольких типов: B-tree, GIN, GiST, BRIN и HASH. Каждый из них использует свой 
алгоритм работы и подходит для определенных запросов. По умолчанию создаются индексы типа B-tree, как поддерживающий 
наиболее часто используемые операции. Чтобы создать индекс другого типа надо указать его явно, добавив модификатор 
USING type.

```sql
CREATE INDEX index_name ON table_name USING type (column_name);
```

Рассмотрим подробнее каждый тип.

**B-tree**

B-tree строит индексы используя [одноименную реализацию](https://ru.wikipedia.org/wiki/B-дерево) сбалансированного 
дерева. Может использоваться в случаях, если к индексированному полю применяются:

- операторы сравнения >, <, =, >=, <=, BETWEEN и IN;

- условия пустоты IS NULL и IS NOT NULL;
- операторы поиска подстроки LIKE и ~, если искомая строка закреплена в начале шаблона (например str_1 LIKE 'search%');
- регистронезависимые операторы поиска подстроки ILIKE и ~*. Но только в том случае, если искомая строка начинается с 
  символа, который одинаков и в верхнем и в нижнем регистре (например числа)`.

**GiST**

GiST для построения индексов использует один из нескольких алгоритмов, наиболее подходящих под тип индексируемого поля. 
Поэтому набор операторов при работе с которыми может быть задействован этот индекс зависит от типа поля. По умолчанию 
PostgreSQL предоставляет индексы для некоторых типов данных, таких как 
[геометрические типы](https://www.postgresql.org/docs/9.5/datatype-geometric.html), 
[сетевые адреса](https://www.postgresql.org/docs/9.1/static/datatype-net-types.html), 
[диапазоны](https://www.postgresql.org/docs/9.2/static/rangetypes.html) и т.д. Так же этот список можно расширить, 
установив соответствующие модули.

Вот список типов полей и индексируемых операторов для них. Значение операторов для каждого конкретного типа можно найти 
в официальной документации.

- типы box, circle и polygon - операторы &&, &>, &<, &<|, >>, <<, <<|, <@, @>, @, |&>, |>>, ~, ~=;
- типы inet и cidr - операторы &&, >>, >>=, >, >=, <>, <<, <<=, <, <=, =;
- тип point - операторы >>, >^, <<, <@, <@, <@, <^, ~=;
- тип tsquery - операторы <@, @>;
- тип tsvector - оператор @@;
- все типы range - операторы &&, &>, &<, >>, <<, <@, -|-, =, @>, @>.

**GIN**

GIN индексы применимы к составным типам, работа с которыми осуществляется с помощью ключей. Это массивы, jsonb и 
tsvector. Как и GiST индексы, они могут реализовать один из нескольких алгоритмов. И стандартный набор можно так же 
расширить, установив модули.

Ниже приведен список типов полей и индексируемых операторов для них. Значение операторов для каждого конкретного типа 
можно найти в официальной документации.

- массивы - операторы &&, <@, =, @>;
- тип jsonb - операторы ?, ?&, ?|, @>;
- тип tsvector - операторы @@ и @@@.

Так же GIN индекс может быть создан только для определенных полей jsonb.

**BRIN**

BRIN индекс отчается от остальных, его идея не в том, чтобы быстро найти нужные строки, а в том, чтобы избежать 
просмотра заведомо ненужных, то есть **ускорить последовательное сканирование** таблицы. Это всегда неточный индекс: он 
вообще не содержит TID-ов табличных строк (ссылок на конкретные строки).

Упрощенно говоря, BRIN хорошо работает для тех столбцов, значения в которых коррелируют с их физическим расположением в 
таблице. Иными словами, если запрос без предложения ORDER BY выдает значения столбца практически в порядке возрастания 
или убывания (и при этом по столбцу нет индексов).

Работает это следующим образом. Таблица разбивается на зоны (range) размером в несколько страниц (или блоков, что то же 
самое) — отсюда и название: Block Range Index, BRIN. Для каждой зоны в индексе сохраняется сводная информация о данных 
в этой зоне. Как правило, это минимальное и максимальное значения, но бывает и иначе. Если при выполнении запроса, 
содержащего условие на столбец, искомые значения не попадают в диапазон, то всю зону можно смело пропускать; если же 
попадают — все строки во всех блоках зоны придется просмотреть и выбрать среди них подходящие.

BRIN можно применять к большому количеству типов данных, вот некоторые из них: числа, строки, дата/время, диопазоны и 
т.д. Список поддерживаемых операторов зависит от типа столбца, для большинства типов поддерживаются операторы 
`<`, `<=`, `=`, `>=`, `>`. Полный список поддерживаемых типов и операторов можно посмотреть в 
[официальной документации](https://postgrespro.ru/docs/postgresql/13/brin-builtin-opclasses#brin-builtin-opclasses-table).

Один из примеров, когда уместно использовать данный индекс это логи или истории заказов магазина, которые пишутся 
последовательно, а потому некоторые колонки (дата, время, номер) частично упорядочены уже на физическом уровне.

Отличительные особенности:

- небольшой размер;
- минимальные накладные расходы на поддержание (разрабатывался для таблиц размеров в несколько терабайтов или даже 
  десятков терабайт).

Детали реализации можно посмотреть [здесь](https://habr.com/ru/company/postgrespro/blog/346460/) и 
[здесь](https://ru.wikipedia.org/wiki/BRIN).

**HASH**

Hash индексы могут использоваться, только если проиндексированное поле участвует в сравнении (только оператор =). Этот 
индекс так же не используется в условиях IS NULL и IS NOT NULL. 

В старых версиях postgres (например 9.5) этот тип индекса не рекомендуется использовать.

> Операции с хеш-индексами в настоящее время не проходят через WAL, так что после аварийной остановки базы данных может 
> потребоваться перестроить хеш-индексы командой REINDEX. Кроме того, изменения в хеш-индексах после начальной копии не
> переносятся при потоковой или файловой репликации, так что в последующих запросах они будут давать неправильные 
> ответы. По этим причинам настоятельно рекомендуется не использовать их.

В новых версиях эти проблемы исправили.

#### Составные индексы

Индекс можно построить больше чем по одному полю. Для построения индекса по нескольких полям - составного индекса, 
надо просто перечислить входящие в него поля через запятую.

```sql
CREATE INDEX index_name ON table_name (column_name_1, compumn_name_2);
```

Максимальное количество полей в индексе - 32. Это значение может быть изменено, если вы самостоятельно компилируете 
PostgreSQL из исходников. Но на практике индексы, состоящие больше чем из трех полей, практически не применяются.

Составными могут быть индексы только B-tree, GiST и GIN типов. Составные индексы могут использоваться, когда в условии 
участвуют все поля, входящие в индекс. Так же составной индекс может быть использован, если условие касается только 
одного или нескольких проиндексированных полей. Для каждого типа есть свои особенности.

**B-tree**

B-tree индекс может быть использован, когда условие включает в себя любые входящие в него поля. Но наиболее полезен он 
в том случае, если в условии задействовано ведущее (первое в списке) поле.

**GiST**

GiST индекс может использоваться в тех же условиях, что и B-tree. Помимо этого эффективность индекса сильно снижается, 
если условие по ведущему полю отсекает мало значений. Нужно стараться так составлять индекс, чтобы наиболее строгое 
ограничение применялось к ведущему полю.

**GIN**

Составной GIN индекс одинаково эффективен при использовании любого входящего в него поля не зависимо от его 
расположения. Это отличает его от B-tree и GiST индексов, где условие по ведущему полю сильно желательно.

**Частичные индексы**

Иногда может возникать ситуация, что индекс требуются не для всех записей в таблице. Например, у нас есть таблица users, 
у которой есть поле is_active типа boolean. Записей со значением поля true намного меньше, чем с false. Но логично, 
что основная часть запросов идет к активным пользователям. В этом случае будет разумно построить индекс только для них. 
PostgreSQL предоставляет такую возможность.

Для создания частичного индекса надо добавить модификатор WHERE в запрос на создание.

```sql
CREATE INDEX index_name ON table_name (column_name) WHERE condition;
```

Вот запрос на создание частичного индекса для поля `users.rating` с условием `is_active = true`:

```sql
CREATE INDEX active_users ON users (rating) WHERE is_active = true;
```

Составные и уникальные индексы тоже могут быть частичными.

#### Функциональные индексы

Порой возникает необходимость создания индекса не для конкретного поля/полей, а для результата выражения. Например, 
если мы часто ищем записи в таблице `users` по имени и фамилии одной строкой. Пример такого запроса:

```sql
SELECT * FROM users where (name || ' ' || surname) = 'Haru Atari';
```

Здесь может сильно помочь функциональный индекс. Для его создания используется обычный запрос, но вместо полей, надо 
указать выражение. Запрос на создание индекса для нашего случая будет выглядеть так:

```sql
CREATE INDEX active_users ON users ((name || ' ' || surname));
```

Важно понимать, что функциональные индексы хранят результат выражения и вычисляют его при вставке или обновлении записи.
Из-за этого сильно возрастает скорость чтения т.к. теперь нет необходимости высчитывать значения выражения для каждой 
записи, а достаточно произвести простое сравнение. Но при этом сильно просаживается скорость при создании и 
редактировании записей т.к. при этом еще и рассчитывается новое значение для индекса.


> Данная заметка скопирована с [сайта](https://web.archive.org/web/20190116120501/https://haru-atari.com/ru/blog/6/indexes-in-postgresql-full-manual),
> после того как владелец удалил свой блог.
 

Полезные ссылки:
   
   - [Индексы - Postgres документация](https://postgrespro.ru/docs/postgresql/13/indexes-types)
   - [Индексы в PostgreSQL — 9 - habr (описание работы brin индексов)](https://habr.com/ru/company/postgrespro/blog/346460/)
   - [BRIN - wikipedia](https://ru.wikipedia.org/wiki/BRIN)


<a name='Оптимизация-запросов'></a>
## Оптимизация запросов

 - [Оптимизация запросов. Основы EXPLAIN в PostgreSQL](https://m.habr.com/ru/post/203320/)
 - [Оптимизация запросов. Основы EXPLAIN в PostgreSQL (часть 2)](https://m.habr.com/ru/post/203386/)
 - [Оптимизация запросов. Основы EXPLAIN в PostgreSQL (часть 3](https://m.habr.com/ru/post/203484/)



<a name='Примеры-решения-задач'></a>
## Примеры решения задач


<a name='Запрет-на-созадние-записей-пересекающихся-по-времени'></a>
### Запрет на создание записей пересекающихся по времени

Данный пример показывает как можно реализовать блокировку на одновременное 
редактирование одного и тоже поста несколькими пользователями с проверкой на 
стороне БД. 

Благодаря ограничению tstzrange_constraint в таблице нельзя создать
несколько записей у которых post_id равен и значения timestamp_start_block и
timestamp_end_block пересекаются.

```sql
CREATE TABLE post (
    id SERIAL PRIMARY KEY,
    name varchar(20)
);

CREATE TABLE post_edit_block (
    id SERIAL PRIMARY KEY,
    post_id INT REFERENCES post (id),
    timestamp_start_block TIMESTAMP WITH TIME ZONE,
    timestamp_end_block TIMESTAMP WITH TIME ZONE
);

CREATE EXTENSION btree_gist;
ALTER TABLE post_edit_block
    ADD CONSTRAINT tstzrange_constraint
        EXCLUDE USING gist (
            post_id WITH =,
            tstzrange(timestamp_start_block, timestamp_end_block, '[]') WITH &&
        );
```

