Golang
==========

# Оглавление

1. <h3>[Настройка системы](#Настройка-системы)</h3>

    - [Установка/удаление](#Установка/удаление)
    - [Настройка окружения](#Настройка-окружения)
 
- [Общие понятия](#Общие-понятия)
- [Кросс-компиляция](Кросс-компиляция)
- [Создание shared library](#Создание-shared-library)
- [Подсчет сколько раз какой символ встретился в строке](#Подсчет-сколько-раз-какой-символ-встретился-в-строке)
- [Автоматическое определение размера массива](#Автоматическое-определение-размера-массива)
- [Функция make](#Функция-make)


<a name='Настройка-системы'></a>
## Настройка системы

<a name='Установка/удаление'></a>
### Установка/удаление

**Установка**

Самый лучший способ установить последнюю версию компилятора на linux это 
использовать менеджер версий GVM. Перед установкой GVM надо установить 
зависимости:

```bash
sudo apt-get install curl git mercurial make binutils bison gcc
```

Теперь можно установить сам GVM:

```bash
bash < <(curl -s https://raw.github.com/moovweb/gvm/master/binscripts/gvm-installer)
```

После того как менеджер версий установлен, необходимо перезапустить консоль 
и можно приступать к установке go. Для этого необходимо выполнить следующие
команды:

```bash
gvm install go1.7.1
gvm use go1.7.1 —default
```

Для того, чтобы проверить, что установка прошла успешно, необходимо выполнить:

```bash
go version
```

Если команда выполняется без ошибок, то значит установка прошла без проблем.

**Удаление**

Для удаления GVM и установленных версий Go нужно просто выполнить

```bash
rm -rf ~/.gvm
```


<a name='Настройка-окружения'></a>
### Настройка окружения

Для того, чтобы приступить к разработке необходимо сначала настроить окружение.
Разработка на go предпогает, что у вас есть 1 папка, в которой располагаются 
все проекты. Структура данной папки следующая:

```
Golang
├── bin
├── pkg
└── src
```

Теперь нужно создать переменные окружения и описать их в файле .bash_profile

```
export GOPATH=~/Golang
export GOBIN=${GOPATH}/bin
export PATH=${PATH}:${GOPATH}/:${GOBIN}
```

**Описание переменных окружения**

- GOROOT - указывает на папку где лежат исходные коды go, стандартная 
    библиотека и т д. Это, что-то вроде JAVA_HOME. Задавать эту переменную 
    нужно только в случае, если устанавливаете go из исходников.
    
    Раньше (до версии 1.0) эта переменная была нужна — её использовали скрипты 
    сборки, равно как и GOARCH и GOOS. Но после Go 1.0 немного изменилась 
    внутренняя логика работы go tool и сейчас значение GOROOT хардкодится на 
    этапе сборки или инсталляции. Тоесть, go — дефолтно проинсталлированный — 
    знает это значение и так. Его можно посмотреть с помощью команды:
    `go env GOROOT` 

- GOPATH - указывает на папку, которая служит «рабочим пространством», то есть 
    там располагаются исходники всех проектов, скомпилированные версии 
    проектов и т д

    Переменная должна задаваться обязательно!

- GOBIN - указывает на папку в которую складываются скомпилированные бинарники.



<a name='Общие-понятия'></a>
### Общие понятия

Файлы с кодом go, имеют расширение go.
Программа на go состоят из пакетов. Пакет можно разбить на любое количество 
файлов, и если все они будут иметь одинаковое объявление пакета, с точки
зрения языка Go все они будут являться частями одного и того же пакета, как 
если бы все их содержимое находилось в единственном файле.

Каждая программа должна иметь пакет main c функцией main, которая является 
точкой входа в программу. Так же пакет main может ещё иметь функцию init, 
которая выполняется перед функцией main.

Запуск

- `go run hello.go` — запускает программу на go;
- `go install` — компилирует файлы из текущего рабочего каталога и кладёт в 
папку bin. Для корректного выполнения команды нужно установить переменную 
окружения GOBIN;
- `go build` — делает тоже самое, что и предыдущая команда, но собранный файл 
помещается в текущую директорию.


<a name='Кросс-компиляция'></a>
### Кросс-компиляция

Сначала нужно собрать toolchane для целевой платформы. Для этого переходим в 
директорию с исходным кодом Go (она же $GOROOT/src, она же всегда есть у вас 
на машине) и пересобираем под нужную платформу, скажем Windows/amd64:

```bash
cd $(go env GOROOT)/src
sudo GOOS=windows GOARCH=amd64 CGO_ENABLED=0 ./make.bash —no-clean
```

Скрипт make.bash — это стандартный скрипт сборки Go, которым бы вы 
инсталлировали Go, если бы ставили из исходников. Он собирает, собственно, 
Go, и всю стандартную библиотеку, только в этот раз — для платформы 
windows/amd64.

Также, по упомянутой выше причине, мы отключили поддержку CGO.

**Значения GOOS и GOARCH**

OS            |     $GOOS
------------- | -------------
Linux         |     linux
MacOS X       |     darwin
Windows       |    windows
FreeBSD       |    freebsd
NetBSD        |     netbsd
OpenBSD       |    openbsd
DragonFly BSD |    dragonfly
Plan 9        |     plan9
Native Client |     nacl
Android       |   android

Architecture           |     $GOARCH
-----------------------| -------------
x386                   |     386
AMD64                  |     amd64
AMD64 с 32 разр. указ. |    amd64p32
ARM                    |    arm


**Сборка проекта**

Переходим в папку проекта и собираем его командой:

```bash
GOOS=windows GOARCH=amd64 go build ./test.go
```

При выполнении данной команды может возникнуть ошибка

```
ERROR: Cannot find /Users/alex/go1.4/bin/go.
Set $GOROOT_BOOTSTRAP to a working Go tree >= Go 1.4.
```

Решить ее заданием переменной окружения GOROOT_BOOTSTRAP может не получиться. 
В этом случае можно создать в папке /Users/alex/ символьную ссылку на папку 
GOROOT. Для того, чтобы это исправить надо выполнить в консоли:

```bash
ln -s $(go env GOROOT) ~/go1.4
```

После этого все должно успешно собраться.

Сссылки на используемые материалы:

- https://habrahabr.ru/post/249449/


<a name='Создание-shared-library'></a>
### Создание shared library

Начиная с go 1.5.1 можно на go создавать библиотеки, для других языках 
программирования.

```go
package main

import "C"

//export add
func add(left, right int) int {
   return left + right
}

func main() {}
```

Перед функциями, которые можно импортировать нужно объявлять комментарий
`export <имя функции>`.

Компиляция должна выполняться с помощью команды:

```bash
go build -buildmode=c-shared -o ./out.so .inp.go
```

После этого скомпилированную библиотеку можно использовать в python следующим 
образом:

```python
from ctypes import cdll

lib = cdll.LoadLibrary('./out.so')
result = lib.add(2, 3)
print(result)
```


<a name='Подсчет-сколько-раз-какой-символ-встретился-в-строке'></a>
### Подсчет сколько раз какой символ встретился в строке

Создаем массив байтов, размером 256 (размер ascii таблицы), он будет 
использоваться для подсчета. Индекс массива будет представлять собой код 
символа, а значение в массиве указывать, сколько раз каждый из символов 
встретится при переборе строки.

```go
package main

import (
   "fmt"
)

func main() {
   counter := make([]int, 256)
   str := "hello"
   for _, char := range str {
      counter[char]++
   }
   for char, count := range counter {
      if count > 0 {
         fmt.Println(string(char), ": ", count)
      }
   }
}
```

<a name='Автоматическое-определение-размера-массива'></a>
### Автоматическое определение размера массива

Обычно при объявлении или создании массива нужно объявлять его длину.

```go
var array1 [5]int  // Объявление массива длиной 5
array2 := [2]int{1, 2}  // Объявление и инициализация массива длиной 2
```

Но если при объявлении массива мы его сразу инициализируем, то можно не 
указывать точную длину, а просто написать три точки. В этом случае компилятор 
сам вычислит длину массива исходя из количества заносимых элементов.

```go
func main() {
    array := [...]int{1, 2, 3, 4} // Объявление и инициализация массива
    fmt.Println(cap(array))
}
```

<a name='Функция-make'></a>
### Функция make

Отображения, срезы и каналы в языке Go создаются с помощью встроенной функции 
`make()`. Она создает значение указанного типа и возвращает ссылку на него. 
Эта ссылка может передаваться, на пример, другим функциям, и все изменения, 
произведенные в значении по этой ссылке, будут видимы в любом месте программы.