Чистый код
==========

# Оглавление

1. <h3>[Принципы проектирования](#Принципы)</h3>

    - [SOLID](#SOLID)
    
2. <h3>[Работа с кодом](#Работа-с-кодом)</h3>

    - [Версионирование (библиотек, программ и т д)](#Версионирование-(библиотек,-программ-и-т-д))
    - [Логирование](#Логирование)


<a name='Принципы'></a>
## Принципы

<a name='SOLID'></a>
### SOLID

SOLID (сокр. от англ. single responsibility, open-closed, Liskov substitution, 
interface segregation и dependency inversion) — мнемонический акроним, пяти 
принципов объектно-ориентированного программирования и проектирования.

1. **Single Responsibility Principle** (Принцип персональной ответственности) - 
    должна существовать лишь одна причина, приводящая к изменению класса.

    То есть каждый класс должен отвечать только за одну конкретную вещь (он не 
    должен быть швейцарским ножом, он должен быть обычным ножом умеющим только 
    резать).
    
    Применяется если:
    
    - код нужно сделать гибким и легко изменяемым
    - заранее сложно определить какие изменения в проекте будут делаться в 
      дальнейшем
    - декомпозировать задачу с самого начала проще, чем потом разделять на 
      несколько частей одну большую систему, по этому лучше с самого начала 
      уделять внимание декомпозиции.
    
    Не стоит применять, когда:
    
    - заранее известно о неизменяемости кода в конкретном месте
    - решение сильно усложняет разработку и поддержку кода
    - архитектурные решения, которые предопределяют реализацию, несмотря на 
      каноны и принципы

2. **The Open Closed Principle** (Принцип открытости/закрытости) - программные 
    сущности должны быть открыты для расширения, но закрыты для модификации.
    
    Цель принципа:

    - разработчик всегда пишет новый код, а не переписывает старый
    - тестирование кода происходит единожды
    - практически не нужно тратить время на частый рефакторинг
    
    При добавлении новой логики мы не должны переписывать старый код (на 
    пример класс), мы должны его только расширять, на пример при помощи 
    наследования.
    
    Пример
    
    ```
    // Проблемный код
    class Order {
    
        func getTotalPrice() {
            // получает все товары из корзины
            // получает скидки пользователя
            // расчитывает итоговую цену
        }
    }
    ```
        
    ```
    // Правильное решение
    abstract class BaseOrderAlgoritm {
        func getTotalPrice() {
            products = this.getProducts()
            discount = this.getDiscount()
            return calculate(products, discount);
        }
        
        func calculate(products, discount) {
            // Расчитывает итоговую цену 
        }
        
        abstract func getProducts() {}
        
        abstract func getDiscount() {}
    }
    
    class SomeOrderStraegy extends BaseOrderAlgoritm {
        func getProducts() {
            // Получает все товары из корзины
        }
        
        func getDiscount() {
            // Вычисляет скидки для конкретного пользователя
        } 
    }
    ```
    
    Как видно из примера для того, чтобы изменить логику подсчета стоимости 
    товара, не нужно переписывать старый код, нужно всего лишь наследоваться от
    базового класса и переопределять необходимые методы.
    
    Также, чтобы решить проблему описанную выше, можно применить принцип
    инверсии зависимостей.
    
    Следует использовать:
    
    - в местах часто подвергаемых изменениям
    - если в коде используются условия, то это служит сигналом к тому, что 
      вероятнее всего в этих местах стоит использовать данный принцип
    - невозможно придумать универсальную абстракцию
    
3. **The Liskov Substitution Principle** (Принцип подстановки Барбары Лисков) - 
    наследующий класс должен дополнять, а не изменять базовый класс.
    
    Цель принципа - помогает реализовать правильное наследование классов.
    
    Данный принцип говорит о том, что не всегда можно наследоваться от 
    какого-то класса.
    
    Пример описывающий проблему:
    
    ```
    // Описывает 2d доску
    class Board {
        integer x, y, tile
        
        func getTile(x, y) {}
        
        func addUnit(x, y) {}
        
        func removeUnits(x, y) {}
        
        func getUnits(x, y) {}
    }
    
    // Описывает 3d доску
    class Board3D extends Board {
        integer z, tile3d
        
        func getTile3d(x, y, z) {}
        
        func addUnit3d(x, y, z) {}
        
        func removeUnits3d(x, y, z) {}
        
        func getUnits3d(x, y, z) {}
    }
    ```
    
    Проблема данного кода в том, что наследующий класс не заменяет классы 
    родителя, а дополняет и в итоге полученный класс имеет конфликтующие друг с 
    другом методы. Это может привести к не правильному использованию класса и
    как следствие к ошибкам.
    
    Для того, чтобы решить проблему кода выше, нужно разделить классы и сделать
    их независимыми.
    
4. **The Interface Segregation Principle** (Принцип разделения интерфейса) - 
    клиенты не должны попадать в зависимость от методов, которыми они не 
    пользуются.
    
    Другая формулировка выглядит следующим образом: 
    Много интерфейсов, специально предназначенных для клиентов, лучше, чем один 
    интерфейс общего назначения.
    
    Цели принципа:

    - принцип борется с "толстыми" интерфейсами
    - по сути это принцип персональной ответственности, но для интерфейсов
    - интерфейс должен быть абстрактным (иметь универсальное имя и ни кому не
      принадлежать)
    
5. **The Dependency Inversion Principle** (Принцип инверсии зависимостей) - модули
    высокого уровня не должны зависеть от модулей низкого уровня. Оба типа 
    модулей должны зависеть от абстракций. Абстракции не должны зависеть от
    подробностей. Подробностям следует зависеть абстракций.
    
    Пример
    
    ```
    // Правильное решение проблемы
    class Order {
        func Order(IProduct product, IDiscount discount) {
            this.product = product
            this.discount = discount
        }
        
        func getTotalPrice() {
            products = this.product.getProducts()
            discount = this.discount.getDiscount()
            
            return calculate(products, discount)
        }
        
        func calculate(products, discount) {
            // расчитывает итоговую цену
        }
    }
    ```
    
    Данный код хороший и гибкий, потому что product и discount создаются не в 
    самом классе, а где-то вне. Следовательно, если нам нужно будет поменять 
    логику работы программы, не нужно трогать реализацию класса Order.
    
>Данная заметка основана [на видеоуроке](https://www.youtube.com/watch?v=59tq5Fcgn7A).

Полезные ссылки:

- [SOLID Principles explained in Python with examples](https://github.com/heykarimoff/solid.python)
- [Принципы SOLID, о которых должен знать каждый разработчик | habr](https://m.habr.com/company/ruvds/blog/426413/)
- [Александр Бармин - Практическое применение принципов SOLID](https://www.youtube.com/watch?v=8Eo6bf-bPes)



<a name='Работа-с-кодом'></a>
## Работа с кодом

<a name='Версионирование-(библиотек,-программ-и-т-д)'></a>
### Версионирование (библиотек, программ и т д)

Учитывая номер версии МАЖОРНАЯ.МИНОРНАЯ.ПАТЧ, следует увеличивать:

- МАЖОРНУЮ версию, когда сделаны обратно несовместимые изменения API.
- МИНОРНУЮ версию, когда вы добавляете новую функциональность, не нарушая 
  обратной совместимости.
- ПАТЧ-версию, когда вы делаете обратно совместимые исправления.

Дополнительные обозначения для предрелизных и билд-метаданных возможны как 
дополнения к МАЖОРНАЯ.МИНОРНАЯ.ПАТЧ формату.

Начинать разработку нужно с версии 0.1.0.

[Семантическое Версионирование 2.0.0](https://semver.org/lang/ru/) - перейдя по
данной ссылке можно прочитать подробное описание того как необходимо работать 
с версиями.


<a name='Логирование'></a>
### Логирование

Логи это мощный инструмент, который при правильном использовании позволяет 
расследовать происшествия, а так же получать различные метрики. В данной 
заметке будут описаны рекомендации, которые позволят получить максимум пользы 
от собранных логов.


**Выбор уровня логирования**

Python предоставляет следующие уровни: debug, info, warning, error, critical.
Ниже будут описаны рекомендации по использованию каждого из уровней. Если 
следовать им, то при помощи логов можно будет легко понять в каком состоянии 
находится система и есть ли в ней серьезные проблемы.

- CRITICAL - Если такое случилось, то вполне можно разбудить кого-нибудь 
  ночью, чтобы устранить проблему. Возможна потеря, порча данных, к примеру.

- ERROR - Нечто критичное для ОПЕРАЦИИ, но не для системы в целом. Такие ошибки
  требуют привлечения специалиста, т.к. должны решаться в ручном режиме. 
  
  Пример: при мерже возникает неизвестное нам исключение, операция фейлится, 
  повтор мержа не имеет смысла, решить можно только в ручном режиме.

- WARNING - Проблема для которой есть автоматическое решение. Например 
  автоматическая повторная попытка запроса.

  Пример: протухла одна из прокси необходимых для работы системы, но проблему
  может решить повторный запрос или автоматическая смена прокси. Ручных 
  действий не требуется.

- INFO - Полезно для понимания происходящего в системе, не требует 
  вмешательства.
  
  Пример: в систему пришёл запрос обновлении информации в бд. Очень полезно 
  залогировать этот момент, чтобы понимать, что происходит в системе и 
  в следствии чего, но никакой проблемы в этом нет, решать нечего.

