Django
======

# Оглавление

1. <h3>[ORM](#ORM)</h3>

    - [Оптимизация запросов](#Оптимизация-запросов)
    - [Профалинг запросов](#Профалинг-запросов)

2. <h3>[Архитектура](#Архитектура)</h3>
    - [Проблемы архитектуры](#Проблемы-архитектуры)



<a name='ORM'></a>
## ORM

<a name='Оптимизация-запросов'></a>
### Оптимизация запросов

При работе ORM нужно быть очень осторожным, потому что не правильное его 
использование может очень сильно увеличить нагрузку на БД. Один из примеров,
когда это может случиться это работа со связаннами таблицами.

Например мы имеем вот такую модель:

```python
class Book(models.Model):
    name = models.CharField('Название', max_length=100)
    category = models.ForeignKey(Category)
    authors = models.ManyToManyField(Author)
```

**select_related**

Предположим мы хотим получить информацию о книге и ее категории. Если решать 
задачу влоб то мы напишем примерно вот такой код:

```python
book = Book.objects.get(pk=book_id)
print(book.name, book.category.name)
```

Проблема данного кода в том, что он заставит ORM сделать 2 запроса к БД. Первый
извлечет информацию о книге, а второй о катерии к которой относится книга.
Для того, чтобы этого избежать необходимо использовать метод `select_related`.
Он говорит ORM, что необходимо сделать запрос с JOIN.

```python
Book.objects.select_related('category').get(pk=book_id)
```

Теперь ORM за 1 запрос извлечет сразу всю нужную нам инфомрацию и при получении
имени категории `book.category.name` не будет генерироваться допольнительный 
запрос.

**prefetch_related**

Кроме получения информации о книге и ее категории у нас может возникнуть 
желание получить информацию о книге и о всех ее авторах. Если решать эту задачу
влоб, то мы столкнемся с проблемой N+1 select.

Для того, чтобы решить ее необходимо использовать метод `prefetch_related`.

```python
book = Book.objects.prefetch_related('authors').get(pk=1)
print([author.full_name for author in book.authors.all()])
```

Этот метод говорит ORM, что необходимо сделать 2 запроса, первый извлеч 
инормацию о книге, а второй извлечет всех авторов связанных с данной книгой.
Это очень сильно разгрузит нашу БД.


<a name='Профалинг-запросов'></a>
### Профалинг запросов

Для того, чтобы получить SQL запрос, который будет сгенерирован при 
использовании ORM удобно использовать `shell_plus` из расширения 
`django-extensions`.

Пример использования:

```
./manage.py shell_plus --print-sql
``` 

```python
User.objects.get(pk=1)
```

```
SELECT "auth_user"."id",
       "auth_user"."password",
       "auth_user"."last_login",
       "auth_user"."is_superuser",
       "auth_user"."username",
       "auth_user"."first_name",
       "auth_user"."last_name",
       "auth_user"."email",
       "auth_user"."is_staff",
       "auth_user"."is_active",
       "auth_user"."date_joined"
FROM "auth_user"
WHERE "auth_user"."id" = 1

Execution time: 0.002466s [Database: default]

<User: username>
```

Полезные ссылки:

- [Showing SQL Queries with Pytest and Django](https://blog.ploetzli.ch/2019/showing-sql-queries-with-pytest-and-django/)



<a name='Архитектура'></a>
## Архитектура


<a name='Проблемы-архитектуры'></a>
## Проблемы архитектуры

Django, как и многие другие фреймворки имеет проблемы с архитектурой описываемой в оф. туториалах.
В случае с django, проблема уходит корнями к первоначальной цели, которую преследовали разработчики. Им нужен был 
простой инструмент для создания новостного сайта, который должен был просто отображать новости. Сложную логику 
реализовывать не требовалось. В результате получился фреймворк, который дает ответ как решать базовые задачи. То есть
из коробки у пользователя есть понятная структура проекта и базовый набор примитивов, которыми необходимо оперировать.

В этот базовый набор входят: view, model и template. Проблема состоит в том, что для создания современного 
приложения их недостаточно, по этому в документации нам предлагается размазывать бизнес логику по сериалайзерам (drf), 
моделям, админке и т.д. Если следовать этому совету, то получится тяжело поддерживаемый проект, где каждое изменение 
может привести к непредвиденным последствиям.

Исправить описанную проблему легко, нужно добавить в проект новую сущность, сервисный объект (Service Object).
Данная сущность должна хранить в себе бизнес логику, которая должна разбиваться на методы с понятным неймингом. 
В идеале, сервисный объект должен выглядеть как описание бизнес процесса на английском языке. 

Схематичный пример:

```python
class CreateNewUser:
   
    def __init__(self, user_data: dict):
        self.user_data = user_data
      
    def create(self):
        if not self._check_user_data(user_data):
           self._notice_about_problem()
           return
        
        self._create_user(user_data)
    
    def _check_user_data(self) -> bool:
        # логика проверки данных введенных при регистрации
        pass
    
    def _notice_about_problem(self):
        # логика уведомления пользователя о возникшей во время проверки проблеме
        pass
    
    def _create_user(self):
        # логика создания в системе нового пользователя
        pass
```

Больше примеров можно посмотреть в прикрепленных к заметке статьям.

Полезные статьи:

- [Паттерн Service Object в Rails](https://4ybakut2004.medium.com/паттерн-service-object-в-rails-11bd26a2efaf)
- [7 паттернов рефакторинга толстых моделей в Rails](https://habr.com/ru/post/158011/)
