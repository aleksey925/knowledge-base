Python
======

# Оглавление

1. <h3>[Настройка системы](#Настройка-системы)</h3>
    - [Работа с нескольколькими версиями python под windows](#Работа-с-нескольколькими-версиями-python-под-windows)
    - [Создание portable версии python для windows](#Создание-portable-версии-python-для-windows)
2. <h3>[Стандартные функции](#Стандартные-функции)</h3>
    - [Попарное объединение элементов итерируемых объектов](#Попарное-объединение-элементов-итерируемых-объектов)
    - [Перевод из одной системы счисления в другую с помощью int()](#Перевод-из-одной-системы-счисления-в-другую-с-помощью-int())
3. <h3>[Типы данных](#Типы-данных)</h3>
    - <h4>[Строки](#Строки)</h4>
        - [Вычисление длинны строки в байтах](#Вычисление-длинны-строки-в-байтах)
    - <h4>[Списки](#Списки)</h4>
        - [Создание строки из списка](#Создание-строки-из-списка)
        - [Разворот списка](#Разворот-списка)
        - [Срезы](#Срезы)
    - <h4>[Словари (dict)](#Словари-(dict))</h4> 
        - [Реализация dict в CPython](#Реализация-dict-в-CPython)   
    - <h4>[Файлы](#Файлы)</h4>
        - [Кодировка файла](#Кодировка-файла)
        - [Работа с большими файлами](#Работа-с-большими-файлами)
        - [Изменение прав доступа, владельца](#Изменение-прав-доступа,-владельца)
        - [Разбиение файла на несколько генераторов](#Разбиение-файла-на-несколько-генераторов)
4. <h3>[Функции](#Функции-раздел)</h3>
    - <h4>[Функции](#Функции)</h4>
        - [Особенности использования lambda в цикле](#Особенности-использования-lambda-в-цикле)
        - [Замыкание](#Замыкание)
    - <h4>[Сопрограммы](#Сопрограммы)</h4>
        - [yield from](#yield-from)
5. <h3>[Классы](#Классы)</h3>
    - <h4>[Основы работы с классами](#Основы-работы-с-классами)</h4>
        - [Спец атрибуты](#Спец-атрибуты)
        - [Реализация доступа по индексу](#Реализация-доступа-по-индексу)
        - [Протокол итераторов](#Протокол-итераторов)
        - [Отличие `__getattr__` от `__getatrribute__`](#Отличие-__getattr__-от-__getattribute__)
        - [MRO](#MRO)
6. <h3>[Исключения](#Исключения)</h3>
    - [Извлечение traceback](#Извлечение-traceback)
    - [Обработчик для не перехваченных исключений](#Обработчик-для-не-перехваченных-исключений)
    - [Цепочки исключений](#Цепочки-исключений)
7. <h3>[Сборщик мусора](#Сборщик-мусора)</h3>
    - [Как работает сборщик мусора (gc)](#Как-работает-сборщик-мусора-(gc))
8. <h3>[Многозадачность](#Многозадачность)</h3>
    - [GIL](#GIL)
9. <h3>[Оптимизация и профилирование](#Оптимизация-и-профилирование)</h3>
    - <h4>[Способы измерения производительности](#Способы-измерения-производительности)</h4>
        - [Измерение производительности отдельных функций](#Измерение-производительности-отдельных-функций)
        - [Замер времени работы с помощью unix программы time](#Замер-времени-работы-с-помощью-unix-программы-time)
    - <h4>[Примеры написания оптимального кода](#Примеры-написания-оптимального-кода)</h4>
        - [Создание списков заполненных определённым числом](#Создание-списков-заполненных-определённым-числом)
        - [Добавление данных в список](#Добавление-данных-в-список)
    - <h4>[Советы по написанию оптимального кода](#Советы-по-написанию-оптимального-кода)</h4>
        - [Мелкие классы](#Мелкие-классы)
        - [Поиск (lookup) очень дорогой](#Поиск-(lookup)-очень-дорогой)
        - [Ввод/вывод (python 3.X)](#Ввод/вывод-(python-3.X))
10. <h3>[Pycharm](#Pycharm)</h3>
    - [Live Template](#Live-Template)
    - [Смена регистра](#Смена-регистра)


<a name='Настройка-системы'></a>
## Настройка системы

<a name='Работа-с-нескольколькими-версиями-python-под-windows'></a>
### Работа с нескольколькими версиями python под windows

Начиная с версии Python 3.3 с интерпретатором поставляется специальный 
launcher, который позволяет выбрать запускаемую версию интерпретатора.

Для корректной работы launcher, вы должны быть уверены, что путь к нему 
прописан в переменной окружения PATH.

Если вы выполните в консоли:
```cmd
py
``` 
Будет запущен интерпретатор выбранный по умолчанию.

Скрипту можно указать, какую кокнретно версию нужно запустить:
```cmd
py -2.7
```
```cmd
py -3
```

<a name='Создание-portable-версии-python-для-windows'></a>
### Создание portable версии python для windows

1. Заходим на оф. сайт и качаем python версии «embeddable zip file»;
2. Разархивируем скачанный файл;
3. Удаляем из извлеченной папки файл с расширенем _pth;
4. Создаем папку lib, извлекаем туда содержимое файла <версия_python>.zip и 
удаляем этот архив;
5. Скачиваем скрипт https://bootstrap.pypa.io/get-pip.py и запускаем его при 
помощи скачанного python. 
6. Теперь можно при помощи pip установить все нужные библиотеки.


<a name='Стандартные-функции'></a>
## Стандартные функции

<a name='Попарное-объединение-элементов-итерируемых-объектов'></a>
### Попарное объединение элементов итерируемых объектов

Из двух (или более) итерируемых последовательностей можно создать один список, 
содержащий кортежи из пар элементов этих последовательностей, а недостающие 
будут заменены None.

В python2, для этого можно использовать стандартную функцию map:

```python
>>> map(None, [1, 2, 3], [1, 2]) 
[(1, 1), (2, 2), (3, None)]
```

В python3, нужно использовать функцию zip_longest из модуля itertools:

```python
>>> from itertools import zip_longest
>>> list(zip_longest([1, 2, 3], [1, 2], fillvalue=None))
[(1, 1), (2, 2), (3, None)]
```

<a name='Перевод-из-одной-системы-счисления-в-другую-с-помощью-int()'></a>
#### Перевод из одной системы счисления в другую с помощью int()

В Python, чтобы перевести число из одной системы счисления в другую не нужно 
городить свои велосипеды, можно воспользоваться встроенной функцией int.

```python
>>> int("AF", 16)
175 
```

В этом примере мы перевели шестнадцатиричное число в десятичную систему 
счисления. Для этого мы в качестве 1 аргумента передали в виде строки число 
в шестнадцатеричной системе счисления и 2 аргументом передали основание 
системы счисления (Основание системы счисления, показывает сколько цифр и 
символов применяется для изображения числа. Например в десятичной системе 
счисления, основание будет 10.).


<a name='Типы-данных'></a>
## Типы данных

<a name='Строки'></a>
### Строки

<a name='Вычисление-длинны-строки-в-байтах'></a>
#### Вычисление длинны строки в байтах

Для того, чтобы вычислить сколько байтов занимает строка нужно:
```python
text = 'Какая-то строка'
print(len(text.encode('utf8')))
```

<a name='Списки'></a>
### Списки


<a name='Создание строки из списка'></a>
#### Создание строки из списка

Свернуть список можно банально использовав цикл:

```python
numbers = ['1', '2', '3', '11']
result = 1
for number in numbers:
    result += number
```

или можно красиво сделать все это в 1 строчку с помощью функции reduce

```python
from functools import reduce
a = ['1', '2', '3', '11']
print(reduce(lambda x1, x2: x1 + ', ' + x2, a))
```

или

```python
a = ['1', '2', '3', '11']
', '.join(a)
```


<a name='Разворот-списка'></a>
#### Разворот списка

Развернуть список можно 2 способами:

```python
print(reversed([1, 2, 3, 4, 5]))
```

или

```python
print([1, 2, 3, 4, 5][::-1])
```


<a name='Срезы'></a>
#### Срезы

Очень часто, надо получить не один какой-то элемент, а некоторый их набор 
ограниченный определенными простыми правилами — например первые 5 или 
последние три, или каждый второй элемент — в таких задачах, вместо перебора 
в цикле намного удобнее использовать так называемый срез (slice, slicing).

Следует помнить, что взяв элемент по индексу или срезом (slice) мы не как 
не меняем исходную коллекцию, мы просто скопировали ее часть для дальнейшего 
использования (например добавления в другую коллекцию, вывода на печать, 
каких-то вычислений). Поскольку сама коллекция не меняется — это применимо 
как к изменяемым (список) так и к неизменяемым (строка, кортеж) 
последовательностям.

Синтаксис среза похож на таковой для индексации, но в квадратных скобках 
вместо одного значения указывается 2-3 через двоеточие:

```
# старт, стоп и шаг
my_collection[start:stop:step]
```

**Особенности работы со срезами**

- Отрицательные значения старта и стопа означают, что считать надо не с 
начала, а с конца коллекции.
- Отрицательное значение шага — перебор ведём в обратном порядке справа налево.
- Если не указан старт [:stop:step]— берём с самого начала коллекции, 
то есть start = 0
- Если не указан стоп [start:: step] — идем до самого конца коллекции, т
о есть stop = 0
- step = 1, то есть последовательный перебор слева направо указывать 
не обязательно — это значение шага по умолчанию. В таком случае 
достаточно указать [start:stop]
- Можно сделать даже так [:] — это значит взять коллекцию целиком
- ВАЖНО: При срезе, первый индекс входит в выборку, а второй нет! То есть от 
старта включительно, до стопа, где стоп не включается в результат. 
Математически это можно было бы записать как [start, stop)

**Именованные срезы**

Чтобы избавится от «магических констант», особенно в случае, когда один и 
тот же срез надо применять многократно, можно задать константы с именованными 
срезами с пользованием специальной функции slice().

Примечание: Nonе соответствует опущенному значению по-умолчанию. 
То есть [:2] становится slice(None, 2), а [1::2] становится slice(1, None, 2).

```python
# задаем константам именованные срезы
>>> NAME, BIRTHDAY = slice(None, 2), slice(2, None)
>>> person = ('Alex', 'Smith', "May", 10, 1980)
>>> person[NAME]
('Alex', 'Smith')
>>> person[BIRTHDAY]
('May', 10, 1980)
```

**Изменнеие списка срезом**

Добавление элементов:

```python
>>> a = [1, 2, 3, 4, 5] 
>>> a[1:1] = ['доп. элемент1', 'доп. элемент2'] 
>>> a 
[1, 'доп. элемент1', 'доп. Элемент2', 2, 3, 4, 5]
```

Замена элементов:
```python
>>> a = [1, 2, 3, 4, 5] 
>>> a[2:] = [10, 15, 20] 
>>> a 
[1, 2, 10, 15, 20]
```

Удаление элементов:

```python
>>> a = [1, 2, 3, 4, 5] 
>>> a[2:] = [] 
>>> a 
[1, 2]
```


<a name='Словари-(dict)'></a>
### Словари (dict)


<a name='Реализация-dict-в-CPython'></a>
#### Реализация dict в CPython

Словари - это неупорядоченные коллекции произвольных объектов с доступом по 
ключу. Их иногда ещё называют ассоциативными массивами или хеш-таблицами.

Перед тем как реализовывать словари в python, разработчики интепретатора 
проанализировали для чего они чаще всего используются в интерпретаторе и не 
только. 

Ниже представлена статистика, которую они собрали:

- именованные параметры функций
    - 1 запись
    - 1-3 элемента
    - часто используется в простых программах
- поиск метода в классе (все методы лежат в словаре, который доступен через 
атрибут `__dict__`) 
    - 1 запись, много чтений
    - 8-16 элементов
    - при наследовании много неудачных чтений с последующим поиском в базовом
    классе
- атрибуты и глобальные переменные
    - много записей и чтений
    - 4-10 элементов
- builtins (все встроенные функции)
    - частые чтения, почти не бывает записи
    - ~150 строковых ключей (python 3.3)
    - по некоторым ключам чтения гораздо чаще чем по другим
- удаление повторов, подсчет элементов
    - однократное чтение по каждому из ключей
    - произвольное количество элементов
    - многократный доступ по одному ключу подрят
- проверка принадлежности
    - словари произвольных размеров
    - создаются 1 раз и затем мало изменяются
    - много вызовов `has_key()` и `__contains__`
-  динамическое отображение (то есть происходит постоянная работа со словарем:
чередующиеся добавления, удаления, чтение и перезапись элементов) 

Примеры

- Удаление дубликатов

    ```python
    dict.fromkeys(seqn).keys()
    ```

    Все опреации записи выполняются при конструировании.

- Подсчет элементов в последовательности

    ```python
    for i in seq:
        d[i] = d.get(i, 0) + 1  
    ```
    
    Выполняется 2 последовательных доступа по ключу и используя метод get мы
    не можем уменьшить количество выполняемых операций.
 
- Создание индекса из словаря списков
    
    ```python
    for page_index, page in enumerate(pages):
        for word in page:
            d.setdefault(word, []).append(page_index)
    ```
    
    setdefault сомещает 2 поиска в одном (в отличии от get).


Как видно из статистики, разработки интерпретатора рассмотрели множество 
вариантов в которых могут использоваться словари и постарались сделать 
максимально универсальную реализацию, оптимизации специфических случаев 
практически не делались.

**Внутренняя реализация в python 2.7**

Расматривается реализация словарей из python 2.7, потому что она достаточно 
проста для понимания и отличий от реализации в python 3.3 не так много.

Словарь это просто последовательная область памяти (массив). Для реализации
был выбран массив, потому что доступ к его элементам максимально быстрый.
В Си коде массив выглядит как массив содержаший струкртуры вида:

```с
typedef struct {
    Py_hash_t me_hash;
    PyObject *me_key;
    PyObject *me_value;
} PyDictKeyEntry;
```  

Описание полей стуктуры:

- me_hash - хэш
- *me_key - указатель на объект, который является ключом
- *me_value - указатель на объект, который является значеним

Легко прикинуть сколько данная структура занимает в места в пяти. Хэш занимает
32/64 бита (в зависимости от разрядности). То есть на 32 битной системе такая 
стуктура будет занимать 12 байт.

Новый словарь в памяти выглядит следующим образом

![](python-notes-index/dict/impl-dict-in-cpython/1.jpg)

*Колонка Idx явно не присутвует и нужна только для удобства восприятия.*

При инициадизации словаря (python 2.7 и 3.3) в нем сразу выделяется место для 8 
значений, это делается для оптимизации. Интересно отметить, что хоть место и
выделено для 8 значений, но 8 элементов в нем храниться не может (это будет 
объяснено далее).

В словаре в качестве ключа может выступать любой НЕ изменяемый объект (строка,
кортеж, frozen set и т д), в том чисте и кастомный объект в котором 
переопределен метод `__hash__`. 

**Добавление нового элемента в словарь**

Для того, чтобы добавить новый элемент в словарь нужно преобразовать ключ в 
индекс массива (таблицы). Это делается следующим образом:

- ключ преобразововывается в число при помощи функции hash.
- у полученного числа берется n младших бит 

Полученное значение и есть необходимый нам индекс массива.

> Особенность массива (таблицы) в том, что ее размер это всегда степень двойки, 
> по этому n бит всегда будет валидным ключом, где n это степень двойки.

Немного подробностей о работе функции hash.

Функция hash это просто builtin функция возвращающая 32/64 битное значение. Для 
вычисления возвращаемого значения используется системная функция, либо
метод `__hash__`, если он переопределен.

Генерируемый хеш должен обладать следующими свойствами:

- для одинаковых значений он всегда должен быть одинакомым
- хеш должен быть один и тот же, даже если представления разные
типами (9, 9.0, complex(9,0))
- похожие значения должны давать сильно отличающиеся хеши

Теперь рассмотрим на примерах как происходит добавление новых элементов в 
словарь:

> Функция bits это не какая-то стандартная функция, она просто выводит
> бинарное представление числа, в данном примере используется только для
> визуализации.

> Ещё необходимо понимать, что в действительности в таблице хранится указатель
> на объект python`а, а не как изображено.

![](python-notes-index/dict/impl-dict-in-cpython/add-new-element-1.jpg)
![](python-notes-index/dict/impl-dict-in-cpython/add-new-element-2.jpg)
![](python-notes-index/dict/impl-dict-in-cpython/add-new-element-3.jpg)
![](python-notes-index/dict/impl-dict-in-cpython/add-new-element-4.jpg)
![](python-notes-index/dict/impl-dict-in-cpython/add-new-element-5.jpg)
![](python-notes-index/dict/impl-dict-in-cpython/add-new-element-6.jpg)
![](python-notes-index/dict/impl-dict-in-cpython/add-new-element-7.jpg)
![](python-notes-index/dict/impl-dict-in-cpython/add-new-element-8.jpg)
![](python-notes-index/dict/impl-dict-in-cpython/add-new-element-9.jpg)
![](python-notes-index/dict/impl-dict-in-cpython/add-new-element-10.jpg)

На данных картинках изображен идеальный случай заполнения словаря, потому что
у нас не возникло коллизий (не было ситуаций, когда для разных значений
вычисленный хэш был одинаковым).

**Поиск значений в словаре**

На данный момент у нас есть заполненный словарь и мы хотим извлечь из него 
интересующие нас значения. Рассмотрим как это реализуется:

- сначала мы вычисляем хэш от ключа
- обрезаем старшие биты
- берем полученное значение и используем его как индекс для доступа к элементам
  массива
  
Если визуализировать, то выглядит это следующим образом:

![](python-notes-index/dict/impl-dict-in-cpython/search-element.jpg)


**Перебор всех елементов словаря**

Кроме поиска конкретного значения, часто возникает задача перебрать все 
элементы словаря (получить все ключи, получить все значения или пройтись по 
парам ключ/значение).





# TODO дописать https://www.youtube.com/watch?v=JhixzgVpmdM 11:55 

<a name='Файлы'></a>
### Файлы


<a name='Кодировка-файла'></a>
#### Кодировка файла

При открытие файла лучше всего всегда явно указывать его кодировку. 
В python3 это делается это вот-так:

```python
file = open('Титульник.txt', encoding='utf-8')
```

В python2, нужно использовать функцию open из модуля codecs:

```python
import codecs
codecs.open('Титульник.txt', encoding='utf-8')
```

Чтобы работать с файлом в кодировке utf8-bom, его нужно открывать 
следующим образом:

python3

```python
inp = open('test', encoding='utf-8-sig')
```

python2
```python
import codecs
inp = codecs.open('test', encoding='utf-8-sig')
```

<a name='Работа-с-большими-файлами'></a>
#### Работа с большими файлами

Правильный подход при работе с большими файлами состоит в том, чтобы не 
загружать в память файл за раз целиком (например методом `readlines()`), а 
считывать файл постепенно:

- `read(n)` позволяет считать заданное количество байт из файла;
- `readline()` считывает за раз только одну строку из файла;
- так-же можно использовать протокол итераторов.

В python протоколом итераций называют такое поведение, когда объект реализует 
метод `__next__` который возврщает при вызове следующие значение, а когда 
объекты кончились возбуждает исключение `Stoplteration`.
Файлы поддерживают итерационный протокол (имееют метод `__next__`), по этому 
правильным вариантом работы с ними будет использование цикла for, так как он 
при своей работе вызывает метод объекта `__next__`, так же он сам перехватывает 
исключение `Stoplteration`.

Пример:

```python
for line in open('file.txt'):
    print(line.upper())
```

Метод `__next__` можно вызывать и ручную используя цикл `while`, но в этом 
случае нужно в ручную перехватывать исключение `StopIteration`.

```python
inp = open('out')
while True:
    try:
        print(inp.__next__())
    except StopIteration:
        break
```

<a name='Изменение-прав-доступа,-владельца'></a>
#### Изменение прав доступа, владельца

**Изменение прав доступа**

```python
import os
script_update = '/home/alex/update.sh'
os.chmod(path=script_update, mode=int('700', base=8))
```

Агрумент mode принимает значение в восьмеричном формате, по этому десятиричное 
представление нужно преобразовывать, перед передачей функции.

**Изменение владельца**

```python
import os
script_update = '/home/alex/update.sh'
os.chmod(path=script_update, mode=int('700', base=8))
```

<a name='Разбиение-файла-на-несколько-генераторов'></a>
#### Разбиение файла на несколько генераторов

```python
import math
import itertools

def openfile(filename):
   with open(filename) as file_:
       for i in file_:
           yield i.strip()

def file_split(filename, parts):
   """
   Разбивает содержимое файла на несколько итераторов
   """
   all_str = sum(1 for i in open(filename, 'r'))  # кол-во строк в файле
   count = math.ceil(all_str / parts)  # размер среза

   offset = 0
   chunks = []  # Итераторы содержащие разные части файла
   for i in range(parts):
       file_ = openfile(filename)
       chunks.append((itertools.islice(file_, offset, offset + count)))
       offset += count

   return chunks
```

<a name='Функции-раздел'></a>
## Функции

<a name='Функции'></a>
### Функции

<a name='Особенности-использования-lambda-в-цикле'></a>
#### Особенности использования lambda в цикле

В цикле анонимные функции нужно использовать с осторожностью, потому что 
они «ленивые». По другому это называется отложенные вычисления. 

> Отложенные вычисления (англ. lazy evaluation, также ленивые вычисления или 
> нестрогие вычисления) — технология, которая позволяет вам отсрочить 
> вычисление кода до тех пор, пока не понадобится получить результат 
> вычислений.

```python
args = [1, 2, 3]
for i in args:
    func = lambda x: x + i  # 3
    print(func(0))  # 4

funcs = []
for j in args:
    funcs.append(lambda x: x + j)
for f in funcs:  # 9
    print(f(0))
```

Пояснения:

- 3 определили функцию, но пока мы ее не вызовем, переменные внутри функции 
не будут инициализированны;
- 4 тут все ожидаемо, тело функции было инициализированно с текущим значением i;
- 9 в этом цикле при вызове любой функции будет выведено число 3. Это 
получается потому, что инициализация lambda функции происходит при её вызове 
(это как раз и есть ленивые вычисления, вычисления происходят только тогда, 
когда это требуется) и при вызове функции перменная j == 3 .

**Вывод**

Анонимные функции инициализируется непосредственно в момент их вызова и если 
значение переменной которая в неё передавалась изменилось, то функция будет 
инициализированна с тем значением которое в ней записано на момент вызова, а 
не с тем, какое передавалось в функцию при создании. В приведённом примере 
выход из цикла происходит, когда j == 3 и получается, что во всех созданных 
функциях j будет равно 3.

**Решение сложившейся проблемы**

Описанную выше проблему можно избежать если изменить код и сделать все так:

```python
funcs = []
for i in range(1, 4):
   funcs.append(lambda arg1, arg2=i: arg1 + arg2)
for f in funcs:
   print(f(1))
```


<a name='Замыкание'></a>
#### Замыкание

Замыкание (англ. closure) — функция первого класса, в теле которой присутствуют
ссылки на переменные, объявленные вне тела этой функции в окружающем коде и 
не являющиеся её параметрами.

Замыкание, также как и экземпляр класса, есть способ представления 
функциональности и данных, связанных и упакованных вместе.

В жизни то, что описано выше выглядит следующим образом:

```python
>>> def foo(a):
...     def bar(b):
...         return b * a 
...     return bar
... 
>>> bar = foo(2)
>>> bar(5)
10
>>> bar(10)
20
```

Как мы видим, функция bar может получать доступ к переменным из области 
видимости foo, это и называется замыканием.



<a name='Сопрограммы'></a>
### Сопрограммы

<a name='yield-from'></a>
#### yield from

yield from можно рассматривать с 2 сторон:

1. Это синтаксический сахар

    Реализация без yield from
    
    ```python
    def generator():
        for i in range(10):
            yield i
    
    def wrapper():
        for i in generator():
            yield i
    
    for i in wrapper():
        print(i)
    ```
    
    Реализация c и спользованием yield from
    
    ```python
    def generator():
        for i in range(10):
            yield i
    
    def wrapper():
        yield from generator()
    
    for i in wrapper():
        print(i)
    ```

2. yield from обеспечивает прозрачный двусторонний канал от вызывающего до 
субгенератора. Это включает получение данных из и отправку данных 
в субгенератор.

**Чтение данных из генератора используя yield from**

```python
def reader():
    """
    Генератор, который создает видимость чтения из файла, сокета и т д
    """
    for i in range(4):
        yield '<< %s' % i

def reader_wrapper(g):
    # Ручной обход данных произведенных reader
    for v in g:
        yield v

wrap = reader_wrapper(reader())
for i in wrap:
    print(i)
# Result
<< 0
<< 1
<< 2
<< 3
```

Вместо ручного обхода данных reader() мы можем просто использовать yield from.

```python
def reader_wrapper(g):
    yield from g
```

Это работает и мы избавились от 1 строки кода.


**Отправка данных в генератор (сопрограмма) используя yield from. Часть 1.**

Сейчас давайте сделаем, что-нибудь более интересное. Создадим сопрограмму 
вызывающую `writer`, который принимает данные и отправляет их в сокет, 
файловый дескриптор и т д.

```python
def writer():
    """
    Сопрограмма, которая записывает данные в сокет, файловый дескриптор и т д
    """
    while True:
        w = (yield)
        print('>> ', w)
```

Теперь главный вопрос как должна выглядеть функция wrapper обрабатывающая 
отправку данных writer, так чтобы любые данные прозрачно передавались от 
`wrapper` к `writer()`.

```python
def writer_wrapper(coro):
    # Будет описана позже
    pass

w = writer()
wrap = writer_wrapper(w)
wrap.send(None)  # "prime" the coroutine
for i in range(4):
    wrap.send(i)

# Ожидаемый результат
>>  0
>>  1
>>  2
>>  3
```

Wrapper должен принять отправленные ему данные и так же должен обработать 
`StopIteration`, когда цикл `for` будет завершен. Очевидно, что просто написать

```python
for x in coro: 
    yield x
```

не получится.

Вот версия, которая работает:

```python
def writer_wrapper(coro):
    coro.send(None)  # prime the coro
    while True:
        try:
            x = (yield)  # Получаем значение, которое будем отправлять
            coro.send(x)  # передаем его для writer
        except StopIteration:
            pass
```

Или вместо этого мы можем написать это:

```python
def writer_wrapper(coro):
    yield from coro
```

Так мы сохраним 6 строчек кода, сделаем код более читаемым и это 
просто работает. Магия!


**Отправка данных в генератор (сопрограмма) используя yield from. Часть 2. 
Обработка ошибок.**

Давайте сделаем предыдущий пример немного сложнее. Что если нашему writer нужно 
обрабатывать исключения? Давайте скажем `writer` обрабатывать `SpamException` и 
выводить ***, если оно произошло.

```python
class SpamException(Exception):
    pass

def writer():
    while True:
        try:
            w = (yield)
        except SpamException:
            print('***')
        else:
            print('>> ', w)
```

Что если не менять `writer_wrapper`? Будет это работать? Давайте проверим!

```python
# writer_wrapper такой как выше (длинная версия)
w = writer()
wrap = writer_wrapper(w)
wrap.send(None)  # "prime" the coroutine

for i in [0, 1, 2, 'spam', 4]:
    if i == 'spam':
        wrap.throw(SpamException)
    else:
        wrap.send(i)


# Ожидаемый результат
>>  0
>>  1
>>  2
***
>>  4

# Полученный результат
>>  0
>>  1
>>  2
Traceback (most recent call last):
  ... redacted ...
  File ... in writer_wrapper
    x = (yield)
__main__.SpamException
```

Не работает, потому что x = (yield) просто возбуждает ошибку и вся программа 
аварийно завершается. Давайте заставим программу работать, будем ловить 
исключения в `writer_wrapper` и вручную кидать их в суб-генератор (`writer`), 
а если ошибки не возникает просто передавать значения в суб-генератор.

```python
def writer_wrapper(coro):
    """Works. Manually catches exceptions and throws them"""
    coro.send(None)  # prime the coro
    while True:
        try:
            try:
                x = (yield)
            except Exception as e:   # This catches the SpamException
                coro.throw(e)
            else:
                coro.send(x)
        except StopIteration:
            pass
```

Это работает.

```python
# Результат
>>  0
>>  1
>>  2
***
>>  4
```

Но и это тоже!

```python
def writer_wrapper(coro):
    yield from coro
```

`yield from` прозрачно обрабатывает отправку значений или кидает исключения 
внутрь суб-генератора.

Хотя это все равно не покрывает все возможные случаи. Что случиться если 
генератор будет закрыт (возникает `StopItaration`)? Что о том случае, если 
суб-генератор возвращает значение (в python 3 генератор может возвращать 
значение), как оно будет возвращаться? Все случаи, которые может обработать 
`yield` from описаны в PEP 380.

Ссылки:
- [Оригинальная статья](http://stackoverflow.com/questions/9708902/in-practice-what-are-the-main-uses-for-the-new-yield-from-syntax-in-python-3)
- [PEP 380 - Syntax for delegating to a sub-generator](http://legacy.python.org/dev/peps/pep-0380/)
- [PEP 342 - Coroutines via Enhanced Generators](http://legacy.python.org/dev/peps/pep-0342/)
- [Dave Beazley's Curious Course on Couroutines](http://dabeaz.com/coroutines/) 
данная статья великолепна для начала. 
[Посмотрите слайды 24-33](http://dabeaz.com/coroutines/Coroutines.pdf) чтобы 
увидеть наглядные примеры.


<a name='Классы'></a>
## Классы

<a name='Основы-работы-с-классами'></a>
### Основы работы с классами

<a name='Спец-атрибуты'></a>
#### Спец атрибуты

- `class.__bases__` - вернет кортеж базовых классов объекта
- `object.__dict__` - возвращает словарь атрибутов объекта


<a name='Реализация-доступа-по-индексу'></a>
#### Реализация доступа по индексу

Для того, чтобы реализовать у класса доступ по индексу. В нём нужно определить 
2 основных метода `__getitem__` и `__setitem__`.
`__getitem__` - отвечает за получение данных содержащихся по указанному индексу.
`__setitem__` - отвечает за присваивание объекту по индексу.

```python
class Test:
    def __init__(self, *args):
        self.data = list(args)

    def __getitem__(self, item):
        """
        Вызывается при доступе к атрибуту класса или по индексу
        """
        if isinstance(item, str):
            return getattr(self, item)
        else:
            return self.data[item]

    def __setitem__(self, key, value):
        """
        Вызывается при присваивании по индексу
        """
        self.data[key] = value

test = Test(1, 2)
print('Доступ атрибуту класса', test.data)
print('Доступ по индексу\n', test[1])

test[0] = 11
print('Присвоили данные по индексу', test.data)
test.data = ['новый', 'список']
print('Присвоили данные через атрибут класса', test.data)
```


<a name='Протокол-итераторов'></a>
#### Протокол итераторов

Работая с python Вы каждый день сталкиваетесь с необходимостью пробежаться по
всем строкам файла или перебрать все элементы списка, словаря или какой-то 
другой коллекции. Наверняка решаете Вы эту задачу простым циклом `for`.

```python
for i in [1, 2, 3]:
    print(i)
```

Вы можете так делать благодаря тому, что эти объекты реализуют протокол 
итераторов. Это значит что они реализуют интерфейс благодаря которому цикл 
`for` знает как их перебрать.

Для того, чтобы класс написаный вами тоже можно было использовать в цикле 
`for`, необходимо переопределить методы: `__iter__`, `__next__`.

Метод  `__iter__` вызывается циклом `for` в самом начале и возвращает 
итератор, при помощи которого можно последовательно перебрать все элементы
контейнера.

Итератор возвращенный методом `__iter__` должен реализовывать метод `__next__`,
который при каждом вызове будет возвращать следующий объект контейнера и так
до тех пор пока элементы не кончатся. Когда элементы кончились он должен 
возбудить исключение `StopIteration`, которое сведетельствует о том, что все 
элементы контейнера были перебраны.

Примеры:

```python
class MyList:

    def __init__(self, *args):
        self.data = args
        self.index = 0

    def __iter__(self):
        """
        Вызывается циклом for, в самом начале, чтобы получить объект,
        который реализует метод __next__, чтобы производить его обход.
        Так как данный класс реализует метод __next__, данный метод
        просто возвращает self.
        """
        return self

    def __next__(self):
        """
        Выдаёт циклу очередной элемент, а когда элементы заканчиваются,
        возбуждает исключение StopIteration
        """
        try:
            data = self.data[self.index]
            self.index += 1
        except IndexError:
            self.index = 0
            raise StopIteration
        return data

my_list = MyList(0, 1, 2, 3, 4)
for i in my_list:
    print(i)
```

Перебор всех атрибутов класса:

```python
class MyList:
    def __init__(self):
        self.atr1 = 0
        self.atr2 = 1
        self.atr3 = 'привет'
        self.atr4 = [1, 2, 3]

    def __iter__(self):
        """
        Вызывается циклом for, в самом начале, чтобы получить объект,
        который реализует метод __next__, чтобы производить его обход.
        Чтобы выполнять итерации над атрибутами класса используем 
        метод __dict__, который содержит словарь атрибутов класса. 
        Функция iter  добавляет в объект метод __next__, для
        поддержки итераций.
        """
        return iter(self.__dict__.values())

my_list = MyList()

for i in my_list:
    print(i)
```

<a name='Отличие-__getattr__-от-__getattribute__'></a>
#### Отличие `__getattr__` от `__getatrribute__`

**`__getattr__`**

Вызывается в тех случая, когда у класса пытаются запросить атрибут, который 
не определен ещё. По этому мы можем переопределить его и указать классу, что 
делать при доступе к несуществующему атрибуту.

```python
>>> class Foo:
...     some = 1
...     def __getattr__(self, item):
...         print('Атрибута "{}" не существует'.format(item))
... 
>>> foo = Foo()
>>> foo.some
1
>>> foo.some1
Атрибута "some1" не существует
```

**`__getattribute__`**

Вызывается при попытке доступа к атрибутам (существующим/не существующим).

```python
>>> class Foo:
...     some = 1
...     def __getattribute__(self, item):
...         print('Обращение к атрибуту "{}"'.format(item))
... 
>>> foo = Foo()
>>> foo.some
Обращение к атрибуту "some"
>>> foo.some1
Обращение к атрибуту "some1"
```

Если в классе одновременно определены оба эти метода, то `__getattr__` больше 
не будет вызываться. Вместо него будет использоваться `__getattribute__`.


<a name='MRO'></a>
#### MRO

- [MRO в Python, или Геометрия бриллианта](https://bartash.wordpress.com/2017/06/14/mro-in-python/)
- [Порядок разрешения методов в Python](https://habr.com/post/62203/)




<a name='Исключения'></a>
## Исключения

<a name='Извлечение-traceback'></a>
### Извлечение traceback

Иногда бывает нужно получить в виде строки полный traceback ошибки, это можно
сделать следующим способом:

```python
import traceback
       
def foo():
    a = 5 / 0

try:
    foo()
except Exception as err:
    print(traceback.format_exc())
```


<a name='Обработчик-для-не-перехваченных-исключений'></a>
### Обработчик для не перехваченных исключений

Пример ниже показывает как можно залогировать не перехваченные исключения.

```python
import sys
import logging

def unhandled_exception_hook(exc_type, exc_value, exc_traceback):
    logging.getLogger('app-name').error(
        '#CRITICAL Возникла непредвиденная ошибка в работе приложения:',
        exc_info=(exc_type, exc_value, exc_traceback)
    )

sys.excepthook = unhandled_exception_hook
```

<a name='Цепочки-исключений'></a>
### Цепочки исключений

Цепочки исключений это способ показать, что выбрасываемое исключение является
следствием неудачной попытки обработать другое исключение.

Для формирования цепочек исключений используется дополнение `from`. При его 
использовании требуется указать ещё одно исключение (класс, либо объект). Этот 
объект будет подвязан к возбуждаемому исключению в атрибут `__cause__` (атрибут 
поддерживает запись). В результате, если возбуждаемое исключение не обработано, 
то на вывод будут отправлены оба исключения:

```python
try:
    print(1 / 0)
except ZeroDivisionError as e:
    raise RuntimeError('Новое исключение') from e
```

Данный код говорит о том, что исключение `RuntimeError('Новое исключение')`
возникло в результате неудачной попытки обработать `ZeroDivisionError`.

Похожий механизм срабатывает автоматически, если исключение возбуждается 
внутри обработчика, либо блока `finally` — предыдущее исключение подвязывается 
в атрибут `__context__` нового:

```python
try:
    print(1 / 0)        
except:
    raise RuntimeError('Неявная цепочка исключений')
```




<a name='Сборщик-мусора'></a>
## Сборщик мусора

<a name='Как-работает-сборщик-мусора-(gc)'></a>
### Как работает сборщик мусора (gc)

Для очистки памяти в CPython используется сразу 2 способа:

- подсчет ссылок
- сборщик мусора (generational garbage collector он же gc)

Алгоритм подсчета ссылок очень простой и эффективный, но у него есть один 
большой недостаток. Он не умеет определять циклические ссылки. Именно из-за 
этого, в питоне существует дополнительный сборщик, именуемый поколенческий GC, 
который следит за объектами с потенциальными циклическими ссылками.

В Python, алгоритм подсчета ссылок является фундаментальным и не может 
отключен, тогда как GC опционален и может быть отключен.

**Подсчет ссылок**

Алгоритм подсчета ссылок это одна из самых простых техник для сборки мусора. 
Объекты удаляются как только на них больше нет ссылок.

В Python, переменные не хранят значения, а выступают в роли ссылок на объекты. 
То есть когда вы присваивайте значение новой переменной, то сначала создается 
объект с этим значением, а уже потом переменная начинает ссылаться на него. 
На один объект может ссылаться множество переменных.

Каждый объект в Python содержит дополнительное поле (счетчик ссылок), в 
котором хранится количество ссылок на него. Как только кто-то ссылается на 
объект, это поле увеличивается на единицу. Если по какой-то причине ссылка 
пропадает, то это поле уменьшается на один.

Примеры, когда количество ссылок увеличивается:

- оператор присваивания
- передача аргументов
- вставка нового объекта в лист (увеличивается количество ссылок для объекта)

Как только счетчик ссылок для определенного объекта достигает нуля 
интерпретатор запускает процесс уничтожения объекта. Если удаленный объект 
содержал ссылки на другие объекты, то эти ссылки также удаляются. Таким 
образом, удаление одного объекта может повлечь за собой удаление других. 

Например, если удаляется список, то счетчик ссылок во всех его элементах 
уменьшается на один. Если все объекты внутри списка больше нигде не 
используются, то они также будут удалены.

Переменные, которые объявлены вне функций, классов и блоков называются 
глобальными. Как правило, жизненный цикл таких переменных равен жизни Python 
процесса. Таким образом, количество ссылок на объекты на которые ссылаются 
глобальные переменные никогда не падает до нуля.

Переменные, которые объявлены внутри блока (функции, класса) имеют локальную 
видимость (т.е. они видны только внутри блока). Как только интерпретатор 
питона выходит из блока он уничтожает все ссылки созданные локальными 
переменными внутри него.

Вы всегда можете проверить количество ссылок используя 
функцию `sys.getrefcount.`

Пример работы счетчика ссылок:

```python
>>> import sys
>>> foo = 'Какая-то строка'
>>> print(sys.getrefcount(foo)) 
2
>>> bar = foo
>>> print(sys.getrefcount(foo)) 
3
>>> del bar
>>> print(sys.getrefcount(foo)) 
2
```

Данный пример наглядно показывает все то, о чем говорилось ранее. Небольшое 
недоумение может вызвать то, что нам вернулись значения 2, 3, 2, а не 1, 2, 1.
Это объясняется тем, что когда переменная передается в функцию,
то счетчик ссылок увеличивается на единицу (это сделано для того, чтобы объект
не был удален в то время, когда он обрабатывается функцией).

Основная причина, из-за которой стандартный интерпретатор (CPython) использует 
счетчик ссылок, является исторической. В настоящее время можно встретить 
множество дебатов по поводу данного подхода. Некоторые люди считают, что 
сборщик мусора может быть намного эффективней без участия алгоритма подсчета 
ссылок. У данного алгоритма есть множество проблем, таких как циклические 
ссылки, блокирование потоков, а также дополнительные накладные расходы на 
память и cpu.

Основным плюсом этого алгоритма является то, что объекты удаляются сразу как 
только они не нужны. 

**Garbage Collector**

Задача GC обрабатывать ситуации, когда у нас есть объекты у которых счетчик 
ссылок не 0, но они более не достижимы из кода. То есть он нужен только для
удаления объектов с циклическими ссылками, которые не были удалены алгоритмом
работающим по умолчанию и опирающимся на подсчете ссылок.
 
Ниже приведен пример визуализирующий проблему циклических ссылок, которую 
решает GC.

```python
import ctypes
import gc

# выключаем GC
gc.disable()


# используется ctypes для доступа к объектам по адресу памяти
class PyObject(ctypes.Structure):
    _fields_ = [("refcnt", ctypes.c_long)]


object_1 = {}
object_2 = {}
object_1['obj2'] = object_2
object_2['obj1'] = object_1

obj_address = id(object_1)

# Удаляем ссылки, таким образом объекты более недоступны в программе, 
# но счетчик ссылок у них не 0
del object_1, object_2

# раскомментируйте для принудительного запуска gc, чтобы убедится, что он 
# удалит недостижимые объекты
# gc.collect()

# проверяем счетчик ссылок
print(PyObject.from_address(obj_address).refcnt)
```

В примере выше, инструкция del удаляет ссылки на наши объекты (не сами 
объекты). Как только Python выполняет инструкцию del эти объекты становятся 
недоступны из Python кода. Однако, с выключенным модулем gc они по прежнему 
будут оставаться в памяти, т.к. они имели циклические ссылки и их счетчик по 
прежнему равен единице. Вы можете визуально исследовать такие связи используя 
библиотеку objgraph. 

Циклические ссылки могут происходить только в “контейнерных” объектах. Т.е. 
в объектах, которые могут хранить другие объекты, например в списках, словарях,
классах и кортежах. GC не следит за простыми и неизменяемыми типами, за 
исключением кортежей. Некоторые кортежи и словари так же исключаются из списка 
слежки при выполнении определенных условий. Со всеми остальными объектами 
гарантированно справляется алгоритм подсчета ссылок.

**Поколения**

Поиск недостижимых из кода программы объектов может занимать очень много 
времени, по этому все объекты разделяются на 3 поколения (0, 1, 2), чем дольше
живет объект, тем в более старшем поколении он будет находится. Поколения 
представляют из себя обычные списки, с которыми работает gc.

Алгоритм распределения по поколениям:

- в поколение 0 попадают все новые объекты, кроме тех, которые НЕ могут 
ссылаться на другие объекты (примерами таких объектов могут служить объекты 
типов str, int and etc);
- в 1 поколение попадают те объекты, которые не были удалены во время нулевой
чистки;
- во 2 поколения попадают объекты пережившие чистку в поколении 1.

Момент запуска GC определяется при помощи специальных значений называемых 
threshold. Для каждого поколения имеется свое знанчение threshold. Посмотреть 
эти значения можно вот так:

```python
>>> import gc
>>> gc.get_threshold()
(700, 10, 10)
```

Таким образом GC запускается:
- для поколения 0 - когда выполняется следующие условие:

    (количесто созданных объектов - количество удаленных объектов) > 700

- для поколения 1 - после того как GC 10 раз отработал для поколения 0
- для поколения 2 - после того GC 10 раз раз отработал для поколения 1

Значения threshold можно изменять при помощи функции `gc.set_threshold`.

**Ограничения GC**

GC не может корректно обрабатывать объекты с переопределенным деструктором 
(`__del__`), потому что он просто не знает в каком порядке их вызывать, чтобы 
не наткнуться в очередном деструкторе на вызов уже удаленного объекта. По этому
объекты с переопредленным деструктором, а так же другие объекты, которые gc
не знает как удалить, он помещает в `gc.garbage`. 

Для того, чтобы очистить этот список, нужно перебрать все элементы этого списка
и разорвать все циклические ссылки (`gc.get_referrers`). После этого данный 
список можно очистить и тогда python сам удалит эти объекты основываясь на
посчете ссылок.

P.S. учитывая сложность и множество нюансов работы с `__del__`, лучше не 
использовать их.

Стоить отметить, что данная проблема была решена в Python 3.4 
(подробнее в [PEP 442](http://legacy.python.org/dev/peps/pep-0442/))

**Советы по оптимизации**

Циклы зачастую случаются в реальных задачах, их можно встретить в задачах с 
графами, связными списками или в структурах данных, где требуется вести учёт 
отношений между объектами. Если ваша программа имеет высокую нагрузку и 
требовательна к задержкам, то, по возможности, циклы лучше избегать. 

В местах, где вы заведомо используйте циклические ссылки, можно использовать 
«слабые» ссылки. Слабые ссылке реализованы в модуле weakref и в отличие от 
обычных ссылок никак не влияют на счётчик ссылок. Если объект со слабой ссылок 
оказывается удалённым, то вместо него возвращается None.

В некоторых случаях полезно отключить автоматическую сборку модулем gc и 
вызывать его вручную. Для этого достаточно вызывать gc.disable() и в 
дальнейшем вызывать gc.collect() вручную.


Материалы используемые для написания заметки:
- [Garbage collector & a bit of memory management - Кирилл Лашкевич - Python Meetup 27.09.2013](https://www.youtube.com/watch?v=6Iw6n43mrVI)
- [Всё, что нужно знать о сборщике мусора в Python - Habr](https://habr.com/post/417215/)
- [Удаление объектов сборщиком мусора - asvetlov](https://asvetlov.blogspot.com/2013/05/gc.html)
- [Подсчет ссылок и сборка мусора в Python](http://python-3.ru/page/podschet-ssylok-i-sborka-musora-v-python)



<a name='Многозадачность'></a>
## Многозадачность

<a name='GIL'></a>
### GIL

[GIL в Python: зачем он нужен и как с этим жить - Григорий Петров](https://www.youtube.com/watch?v=AWX4JnAnjBE)



<a name='Оптимизация-и-профилирование'></a>
## Оптимизация и профилирование

<a name='Способы-измерения-производительности'></a>
### Способы измерения производительности

<a name='Измерение-производительности-отдельных-функций'></a>
#### Измерение производительности отдельных функций

Измерить производительность отдельных функций (их время выполнения) можно при 
помощи функции timeit из модуля timeit.

```python
import timeit

def test1():
    res = [[3 for x in range(50)] for x in range(50)]

print(timeit.timeit("test1()", setup="from __main__ import test1", number=100000))
```

Первым аргументом функция timeit принимает код, продолжительность работы 
которого нужно измерить. Второй аргумент — это инструкция, которая выполняется 
1 раз, для настройки окружения. Третий агрумент, задаёт число повторных 
запусков тестируемого кода.


<a name='Замер-времени-работы-с-помощью-unix-программы-time'></a>
#### Замер времени работы с помощью unix программы time

Замерять время выполнения написанной программы можно с помощью стандарной 
Unix программы time (не нужно путать с одноименной программой bash). 

Пример: 

```bash
time python3 get_email.py
```

Вывод программы: 

- real 0m2.784s - реальное время выполнения между вызовом и завершением
- user 0m0.054s - время CPU, которое занял пользователь (сумма значений 
tms_utime и tms_cutime в структуре struct tms, которая возвращается 
вызовом times)
- sys  0m0.010s - время CPU занятое системой (сумма значений tms_stime и 
tms_cstime в структуре struct tms, которая возвращается вызовом times)


<a name='Примеры-написания-оптимального-кода'></a>
### Примеры написания оптимального кода

<a name='Создание-списков-заполненных-определённым-числом'></a>
#### Создание списков заполненных определённым числом

Есть задача: «Создать список 50*50 целых чисел и заполненный тройками.».

Её можно решить несколькими способами:

- Использовать генераторы списков для создания и заполнения списка тройками
    ```python
    [[3 for x in range(50)] for x in range(50)]
    ```
    такой способ будет работать, но как показали замеры, работает он 
    достаточно медленно 9.265034271054901.
- Использование операции умножения для получения списка
    ```python
    [[3] * 50 for _ in range(50)]
    ```
    как показали тесты, данный способ работает значительно быстрее 1.407502235029824.
    

<a name='Добавление-данных-в-список'></a>
#### Добавление данных в список

Добавление большого колличесва данных в список, это распространненая задача и 
решать ее можно по разному. Вот некоторые из вариантов, которые могут 
использоваться:

- в цикле добавлять данные при помощи метода append
- использовать генератор списков

Из перечисленных выше вариантов быстрее всего будет отрабатывать генератор
списков и если есть возможность, то лучше использовать его.

Если ситуация не позволяет (на пример перед добавлением должна выполнится 
дополнительная логика), то необходимо использовать следующую оптимизацию:

```python
res = []
append = res.append
for i in range(10):
    append(input('Введите данные: '))
```

В данном примере мы сохраняем в локальную переменную ссылку на метод `append`
и потом сразу используем эту ссылку сразу, а не вызываем каждый раз данный метод
у объекта res. Данный подход позволяет нам сэкономить драгоценное время, так 
как python не будет каждый раз искать у объекта метод `append`.

При написании, кода лучше всегда помнить про подобного рода трюк, потому что в 
python lookup`ы в python очень "дрогие".


<a name='Советы-по-написанию-оптимального-кода'></a>
### Советы по написанию оптимального кода

<a name='Мелкие-классы'></a>
#### Мелкие классы

Создание фунций более дешёвая операция по сравнению с созданием экземпляра 
класса. По этому если в коде очень часто приходится создать экземпляр 
какого-то класса, нужно подумать как можно переписать этот код. Можно 
постараться избавиться от создания лишних экземпляров класса или вообще 
переписать этот участок кода в функциональном стиле.

По этой же причине не рекомендуется плодить у себя в проекте кучу маленьких 
классов, реализующих буквально несколько методов.


<a name='Поиск-(lookup)-очень-дорогой'></a>
#### Поиск (lookup) очень дорогой

Операции поиска:

- локальных/глобальных переменных
- замыкания
- атрибутов/методов

Это ОЧЕНЬ ДОРОГИЕ операции и 90% времени python занимается именно этим, по 
этому нужно быть с этим очень осторожным.

Для того, чтобы оптимизировать код, нужно запомнить в локальные перменные все, 
что нам нужно.

```python
def list_create():
    res = []
    __append = res.append
    for i in range(10):
        __append(input('Введите данные: '))
```

Так как мы 1 раз нашли метод append и сохранили его в свою локальную 
переменную, то в цикле мы не выполняем многократно дорогостоящий поиск, а 
вызываем нужный метод из локальной переменной.

Если наша функция list_create должна выполняться много раз, то глупо будет 
постоянно инициализировать наши локальные переменные, предназначены для 
запоминания часто используемых функциий. Для оптимизации этого момента можно 
использовать coroutines.

```python
def coroutine(func):
    def wrapper(*args, **kwargs):
        gen = func(*args, **kwargs)
        next(gen)
        return gen
    return wrapper

@coroutine
def list_create():
    args = ()
    res = []
    __append = res.append
    __clear = res.clear
    while True:
        __clear()
        for i in args:
            __append(i)
        args = yield res
        
list_create_cor = list_create()
print(list_create_cor.send(('foo', 'spam', 'list')))
```


<a name='Ввод/вывод-(python-3.X)'></a>
#### Ввод/вывод (python 3.X)

Функция `input` реализует дополнительную логику, по этому если нужно считывать 
данные со стандартного ввода и делать это очень быстро, то лучше напрямую 
обращаться к `sys.stdin`.

Считывать c stdin можно с помощью 2 методов:

- `read()` - читает данные до тех пор, пока не будет получен EOF (обычно это Ctrl+D)
- `readline()` - читает до тех пор, пока не будет нажат Entre.

**Пример задачи, где это может пригодиться:**

Ограничения: 1.5 секунды, 64 МБ памяти
На стандартный ввод программе сначала передаётся количество чисел, которые 
нужно считать, потом происходит ввод этих чисел. После этого опять передаётся 
количество чисел, которые нужно будет считать и после последовательно вводятся
эти числа.

Вы должны вывести одно число — количество чисел во втором списке, которые 
также содержатся в первом.

Пример входных данных:

|Входные данные|Результат|
|--------------|---------|
|2             |2        |
|1054          |         |
|1492          |         |
|4             |         |
|1492          |         |
|65536         |         |
|1492          |         |
|100           |         |


Решение с использованием `input`

```python
required_size = int(input())
required = {input() for i in range(required_size)}

written_size, result = int(input()), 0
for i in range(written_size):
    result += input() in required
 
print(result)
```

Решение с использованием прямого чтения из `sys.stdin`

```python
import sys
 
required_size = int(sys.stdin.readline())
required = {sys.stdin.readline() for i in range(required_size)}
 
written_size, result = int(sys.stdin.readline()), 0
for i in range(written_size):
    result += sys.stdin.readline() in required
 
print(result)
```

Если решать в лоб и использовать input(), то программа выполнится за 1.528, 
а если на прямую читать с sys.stdin, то программа выполнится за 0.858.


<a name='Pycharm'></a>
## Pycharm

<a name='Live-Template'></a>
### Live Template

Live Templates это функция позволяющая вставлять в ваш код часто используемые 
конструкции.

Одна из часто использумых конструкций это `if __name__ == '__main__':`. Для
того, чтобы ее вставить необходимо начать вводить `main` и в сплывающем окне с 
посказками выбрать нужный пункт и нажать enter.

Прочитать о других шаблонах можно в официальной документации.


<a name='Смена-регистра'></a>
### Смена регистра

Нужно выделить нужный текст и выбрать пункт Edit — Toggle case или же 
нажать Ctrl+Shift+U 